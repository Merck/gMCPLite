[{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Graphical testing for group sequential design","text":"document intended evaluate statistical significance graphical multiplicity control used group sequential design (Maurer Bretz 2013). particular, demonstrate design analysis complex oncology trial. many details building necessarily simple example provided Maurer Bretz (2013). combination tools provided gMCPLite gsDesign packages non-trivial, developed way meant re-used straightforward fashion. found particularly valuable provide prompt verifiable conclusion multiple trials Burtness et al. (2019) 14 hypotheses evaluated using template . Given complexity involved, substantial effort taken provide methods check hypothesis testing. initial testing done using sequential p-values (Liu Anderson 2008) can plugged standard graphical hypothesis testing R package, gMCP (Bretz, Maurer, Posch 2009). graphical testing produces sequence including original multiplicity graph, followed updated multiplicity graphs, single hypothesis rejected previous graph. final graph, assuming hypotheses rejected, provides final Type error available testing hypothesis rejected. Updated group sequential bounds hypothesis largest alpha-level evaluated can checked vs. nominal p-values analysis verify testing conclusions reached methods. table contents lays organization document. short, begin 1) design specification followed 2) results entry includes event counts nominal p-values testing, 3) carrying hypothesis testing, 4) verification hypothesis testing results.","code":""},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"design","dir":"Articles","previous_headings":"","what":"Design","title":"Graphical testing for group sequential design","text":"template example, 3 endpoints 2 populations resulting 6 hypotheses tested trial. endpoints : Overall survival (OS) Progression free survival (PFS) Objective response rate (ORR) populations studied : overall population (subjects) subgroup (Subgroup) simplicity, design assuming control group exponential time event median 12 months OS 5 months PFS. design proportional hazards assumption. ORR control group assumed 15%. choices arbitrary, intent fully specify patients enrolled followed \\(\\alpha\\)-controlled study analyses. following design characteristics also specified well-characterize outcomes subjects end trial: Enrollment assumed occur 18 months. Enrollment continue targeted number subjects enrolled subgroup ensure power planned population. means, overall population sample size random power may vary planned . enrollment increases 25% first two months 50% second 2 months 75% third two months final steady state enrollment continues end month 6 enrollment final enrollment expected 18 months. first interim analysis conducted 6 months final patient enrolled adequately assess ORR patients. Thus, analysis planned 24 months start study enrollment, adapted according final enrollment completed. analysis ORR interim analysis PFS OS whatever event counts available cutoff. second interim analysis conducted 14 months final enrollment ensure minimum follow-almost 3 times assumed control median PFS subjects. delayed 3 months final targeted event count PFS subgroup achieved time. ensure complete description tail behavior PFS case PFS curve plateau. PFS OS analyzed. endpoint counts OS overall population PFS random since cutoff determined PFS endpoint count subgroup. final analysis performed 24 months final enrollment, ensuring 2 times assumed median control survival minimum follow-subjects. analysis OS planned. final analysis may delayed 6 months targeted OS event count subgroup achieved. Thus, planned total duration trial OS endpoint 42 months. sample size trial driven adequate sample size targeted events subgroup ensure 90% power OS endpoint assuming hazard ratio 0.65. group sequential designs, assume 1-sided testing. reveal code blocks remainder document, press code buttons indicated throughout. initial code block sets options loads needed packages; modification required user.","code":"### THERE SHOULD BE NO NEED TO MODIFY THIS CODE SECTION # Prefer fixed notation old <- options(scipen = 999) # Colorblind palette cbPalette <- c(\"#999999\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\") # 2 packages used for data storage and manipulation: dplyr, tibble library(dplyr) library(tibble) # 2 packages used for R Markdown capabilities: knitr, kableExtra library(knitr) library(kableExtra) library(gt) library(ggplot2) # For plotting library(gsDesign) # Group sequential design capabilities library(gMCPLite) # Multiplicity evaluation"},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"multiplicity-diagram-for-hypothesis-testing","dir":"Articles","previous_headings":"Design","what":"Multiplicity diagram for hypothesis testing","title":"Graphical testing for group sequential design","text":"Following multiplicity graph trial design. arbitrarily split Type error equally subgroup overall populations. \\(\\alpha\\) allocated OS least ORR, PFS receiving intermediate amount. reflects priority endpoints well practicality detect clinically significant differences population. Reallocation endpoint proceeds subgroup overall population. overall population hypothesis rejected given endpoint, reallocation split two populations another endpoint. choice allocation reallocation illustrated demonstrate complex multiplicity scenario; actually applying method allocation realloation choices carefully considered.  testing scheme can result might referred time travel passing \\(\\alpha\\). , PFS hypotheses rejected given analysis (say final PFS analysis) OS hypotheses rejected final analysis, previously evaluated PFS tests interim final PFS analysis can compared updated bounds based reallocated Type error. practice encouraged Maurer Bretz (2013), acknowledged control Type error previous discussed (Liu Anderson 2008). Given stringent Type error control multiple hypotheses, ability acknowledge clinically significant differences statistically significant can important describing treatment benefits regulatory labeling treatment.","code":"### THIS CODE NEEDS TO BE MODIFIED FOR YOUR STUDY # If needed, see help file for gMCPLite::hGraph() for explanation of parameters below # Hypothesis names nameHypotheses <- c(   \"H1: OS\\n Subgroup\",   \"H2: OS\\n All subjects\",   \"H3: PFS\\n Subgroup\",   \"H4: PFS\\n All subjects\",   \"H5: ORR\\n Subgroup\",   \"H6: ORR\\n All subjects\" ) # Number of hypotheses to be tested nHypotheses <- length(nameHypotheses) # Transition weights for alpha reallocation (square matrix) m <- matrix(c(   0, 1, 0, 0, 0, 0,   0, 0, .5, .5, 0, 0,   0, 0, 0, 1, 0, 0,   0, 0, 0, 0, .5, .5,   0, 0, 0, 0, 0, 1,   .5, .5, 0, 0, 0, 0 ), nrow = 6, byrow = TRUE) # Initial Type I error assigned to each hypothesis (one-sided) alphaHypotheses <- c(.01, .01, .004, 0.000, 0.0005, .0005) fwer <- sum(alphaHypotheses) # Make a ggplot representation of the above specification and display it g <- gMCPLite::hGraph(6,   alphaHypotheses = alphaHypotheses, m = m, nameHypotheses = nameHypotheses,   palette = cbPalette,   halfWid = 1, halfHgt = .35, xradius = 2.5, yradius = 1, offset = 0, trhw = .15,   x = c(-1.25, 1.25, -2.5, 2.5, -1.25, 1.25), y = c(2, 2, 1, 1, 0, 0),   trprop = 0.4, fill = as.character(c(2, 2, 4, 4, 3, 3)) )  print(g)"},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"group-sequential-designs-for-each-hypothesis","dir":"Articles","previous_headings":"Design","what":"Group sequential designs for each hypothesis","title":"Graphical testing for group sequential design","text":"example, assume 1-sided testing non-binding futility bound required Maurer Bretz (2013) design using group sequential design graphical multiplicity control. demonstrated example code respective hypotheses. Efficacy \\(\\alpha\\)-spending group sequential designs uses Lan DeMets (1983) spending function approximating O’Brien-Fleming bound. section needs modified user match study design consideration. uncomfortable coding may wish design using gsDesign Shiny app provides point click interface, also code tab generates R code can copied plugged designs . H1: OS, Subgroup H2: OS, H3: PFS, Subgroup H4: PFS, H5 H6: ORR assume 50% population subgroup interest. sample size 378 driven overall survival (OS) subgroup assume hazard ratio 0.65. assume one-sided group sequential design futility bound. One-sided group sequential design 3 analyses, time--event outcome sample size 378 284 events required, 90 percent power, 1 percent (1-sided) Type error detect hazard ratio 0.65. Enrollment total study durations assumed 18 42 months, respectively. Efficacy bounds derived using Lan-DeMets O’Brien-Fleming approximation spending function none = 1. text automatically generated edited appropriately description design. Following summary table describing study bounds. total sample size assumed twice , N=756. power hazard ratio can adjusted appropriately size trial rather starting adjusting sample size reach targeted power. example, consider altering power (beta) fixing hazard ratio 0.75, representing increase median OS 12 months control group 16 months experimental group. design, consider non-binding futility bound trial may stopped early overall population bound crossed. use Hwang, Shih, De Cani (1990) bound \\(\\gamma = -3.25\\). Study designers carefully consider implication parameter choices, particularly futility bounds provide sensible guidance stopping trial. Since futility bounds non-binding, efficacy bound computed assuming futility bound ignored control Type error targeted level even futility bound crossed trial continued. Asymmetric two-sided group sequential design non-binding futility bound, 3 analyses, time--event outcome sample size 756 589 events required, 86 percent power, 1 percent (1-sided) Type error detect hazard ratio 0.75. Enrollment total study durations assumed 18 42 months, respectively. Efficacy bounds derived using Lan-DeMets O’Brien-Fleming approximation spending function none = 1. Futility bounds derived using Hwang-Shih-DeCani spending function gamma = -3.25. Design OS subjects can also plot different design characteristics. , plot approximate hazard ratio cross bound may helpful design team discussions.  progression free survival (PFS) assume shorter median time event 5 months. assumed hazard ratio 0.65, adjust beta timing match targeted sample size interim analysis timing. assume larger dropout rate PFS OS. set futility bound safety. asymmetric 2-sided design futility efficacy boundary crossing probabilities null hypothesis. parameter astar = 0.1 specifies total lower bound spending 10%. lower Hwang, Shih, De Cani (1990) spending bound \\(\\gamma = -8\\) intended conservative terms futility interim, still provide safety bound PFS result targeted population. carefully evaluated study design team time design. Asymmetric two-sided group sequential design non-binding futility bound, 2 analyses, time--event outcome sample size 378 296 events required, 85.1 percent power, 0.4 percent (1-sided) Type error detect hazard ratio 0.65. Enrollment total study durations assumed 18 32 months, respectively. Efficacy bounds derived using Lan-DeMets O’Brien-Fleming approximation spending function none = 1. Futility bounds derived using Hwang-Shih-DeCani spending function gamma = -8. Design PFS subgroup Finally, design PFS subjects. case, simplify one-sided design. futility bound considered, appropriate. Design PFS overall population objective response rate (ORR), assume underlying control rate 15%. subgroup population, almost 90% power detect 20% improvement. subjects population, approximately 95% power detect improvement ORR 15% 30%.","code":"osmedian <- 12 # Median control survival # Derive group sequential design for OS in the targeted subgroup ossub <- gsDesign::gsSurv(   k = 3, # 3 analyses for OS   test.type = 1, # Efficacy bound only (no futility)   alpha = alphaHypotheses[1], # Allocated alpha from design hypothesis group   beta = 0.1, # Type 2 error (1 - power)   hr = 0.65, # Assumed hazard ratio for power calculation   timing = c(0.61, 0.82), # Choose these to match targeted calendar timing of analyses   sfu = sfLDOF, # Spending function to approximate O'Brien-Fleming bound   lambdaC = log(2) / osmedian, # Exponential control failure rate   eta = 0.001, # Exponential dropout rate   gamma = c(2.5, 5, 7.5, 10), # Relative enrollment rates by time period   R = c(2, 2, 2, 12), # Duration of time periods for rates in gamma   T = 42, # Planned study duration for OS   minfup = 24 # Planned minimum follow-up after end of enrollment ) tab <- gsDesign::gsBoundSummary(ossub) rownames(tab) <- 1:nrow(tab) cat(summary(ossub)) # tab %>% kable(caption = \"Design for OS in the subgroup.\") %>% kable_styling() tab %>%   gt() %>%   tab_header(title = \"Design for OS in the Subgroup\") %>%   cols_align(align = \"left\", columns = Value) %>%   tab_footnote(     footnote = \"Cumulative boundary crossing probability includes crossing probability at earlier analysis.\",     locations = cells_body(columns = \"Value\", rows = c(9, 10, 14, 15))   ) %>%   tab_footnote(     footnote = \"Approximate hazard ratio at bound.\",     locations = cells_body(columns = \"Value\", rows = c(3, 8, 13))   ) hr <- .75 beta <- .14 os <- gsDesign::gsSurv(   k = 3, test.type = 4, alpha = 0.01, beta = beta, hr = hr,   timing = c(0.62, 0.83), sfu = sfLDOF,   sfl = sfHSD, sflpar = -3.25,   lambdaC = log(2) / 12, eta = 0.001, S = NULL,   gamma = c(2.5, 5, 7.5, 10), R = c(2, 2, 2, 12),   T = 42, minfup = 24 ) tab <- gsDesign::gsBoundSummary(os) rownames(tab) <- 1:nrow(tab) cat(summary(os)) tab %>%   kable(caption = \"Design for OS in all subjects\") %>%   kable_styling() plot(os, plottype = \"HR\", xlab = \"Events\") hr <- .65 beta <- .149 pfssub <- gsDesign::gsSurv(   k = 2, test.type = 6, astar = 0.1, alpha = 0.004, beta = beta, hr = hr,   timing = .87, sfu = sfLDOF,   sfl = sfHSD, sflpar = -8,   lambdaC = log(2) / 5, eta = 0.02, S = NULL,   gamma = c(2.5, 5, 7.5, 10), R = c(2, 2, 2, 12),   T = 32, minfup = 14 ) tab <- gsDesign::gsBoundSummary(pfssub) rownames(tab) <- 1:nrow(tab) cat(summary(pfssub)) tab %>%   kable(caption = \"Design for PFS in the subgroup\") %>%   kable_styling() hr <- .74 beta <- .15 pfs <- gsDesign::gsSurv(   k = 2, test.type = 1, alpha = 0.004, beta = beta, hr = hr,   timing = .86, sfu = sfLDOF,   lambdaC = log(2) / 5, eta = 0.02, S = NULL,   gamma = c(2.5, 5, 7.5, 10), R = c(2, 2, 2, 12),   T = 32, minfup = 14 ) tab <- gsDesign::gsBoundSummary(pfs) rownames(tab) <- 1:nrow(tab) tab %>%   kable(caption = \"Design for PFS in the overall population\") %>%   kable_styling() nBinomial(p1 = .35, p2 = .15, alpha = .0005, n = 378) #> [1] 0.8911724 nBinomial(p1 = .3, p2 = .15, alpha = .0005, n = 756) #> [1] 0.9530369"},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"design-list","dir":"Articles","previous_headings":"Design","what":"Design list","title":"Graphical testing for group sequential design","text":"Now associate designs hypotheses ordered list corresponding order multiplicity graph setup. Since ORR designs group sequential, enter NULL values last 2 entries design list; hit code button reveal code .","code":"### THIS NEEDS TO BE MODIFIED TO MATCH STUDY gsDlist <- list(ossub, os, pfssub, pfs, NULL, NULL)"},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"spending-plan-and-spending-time","dir":"Articles","previous_headings":"Design","what":"Spending plan and spending time","title":"Graphical testing for group sequential design","text":"relatively straightforward set timing analyses match different hypotheses, accumulation endpoints can vary plan variety ways. Planning deal critical time protocol development avoid later amendments inappropriate \\(\\alpha\\)-allocation early analyses. going examples, review concept \\(\\alpha\\)-spending refer spending time. given hypothesis, assign non-decreasing spending function \\(f(t)\\) defined \\(t\\ge 0\\) \\(f(0)=0\\) \\(f(t)=\\alpha\\) \\(t\\ge 1\\). assume \\(K\\) analyses observed event counts \\(n_k\\) analysis \\(k=1,2,\\ldots,K\\) targeted final event count \\(N_k\\). \\(\\alpha\\)-spending analysis \\(k\\) originally defined (Lan DeMets 1983) \\(f(t_k=n_k/N_K)\\). values \\(n_k/N_K\\) referred information fraction, \\(k=1,\\ldots,K\\). used pre-specify cumulative amount Type error hypothesis analysis. Lan DeMets (1989) noted calendar time another option \\(t_k\\) values, \\(k=1,\\ldots,K.\\) Proschan, Lan, Wittes (2006) noted long \\(t_k\\) increasing \\(k\\), can used define spending; subject requirement null hypothesis, timing must selected way correlated test statistic (e.g., blinded). refer \\(t_k\\), regardless definition, spending time hypothesis. Note joint distribution interim final tests hypothesis driven \\(n_k\\), \\(k=1,\\ldots,K\\). equivalent basing correlation information fraction \\(n_k^{(actual)}/n_K^{(planned)}\\), \\(1\\le k\\le K\\). Thus, spending time information fraction required compute bounds group sequential testing. general objectives : Spend Type error hypothesis combined interim final analyses; requires spending time 1 final analysis hypothesis. Ensure spending time well defined analysis hypothesis. assume follow-duration event counts may interest determining timing analyses; e.g., immuno-oncology therapies delayed treatment effects tail time--event distribution important establish benefit. Thus, assume -spending interim analysis avoided. assume subgroup prevalence -estimated study design indicating spending time can used deal deviation plan.","code":""},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"results-entry-at-time-of-analysis","dir":"Articles","previous_headings":"","what":"Results entry at time of analysis","title":"Graphical testing for group sequential design","text":"Results analysis performed entered . begin documenting timing event counts analysis. proceed enter nominal 1-sided testing p-values analysis hypothesis.","code":""},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"timing-of-analyses-and-resulting-event-counts-and-spending-times","dir":"Articles","previous_headings":"Results entry at time of analysis","what":"Timing of analyses and resulting event counts and spending times","title":"Graphical testing for group sequential design","text":"Recall design assumed 50% prevalence subgroup. assume observed prevalence 40% , specification stated , enroll targeted subpopulation 378 achieved. assumed occur 22 months total enrollment 940. Timing analyses now targeted follows: first interim scheduled 28 months, 6 months final enrollment. second interim scheduled later 14 months final enrollment (22 + 14 = 36 months start enrollment) targeted final PFS event count 297 events. assume event count reached 34 months achieved final event count 320 subgroup 36 months. final analysis scheduled 24 months final enrollment (month 22 + 24 = 46) 284 events observed subgroup, whichever comes first; also qualification final analysis 30 months final enrollment (6 months targeted time). assume targeted event count reached 6 months targeted final analysis time , thus, final analysis cutoff set month 22 + 30 = 52 time 270 OS events observed subgroup. leads event counts spending PFS OS follows:","code":"### THIS NEEDS TO BE MODIFIED TO MATCH YOUR STUDY # PFS, overall population pfs$n.I <- c(675, 750) # PFS, subgroup pfssub$n.I <- c(265, 310) # OS, overall population os$n.I <- c(529, 700, 800) # OS, subgroup ossub$n.I <- c(185, 245, 295)"},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"nominal-p-values-for-each-analysis","dir":"Articles","previous_headings":"Results entry at time of analysis","what":"Nominal p-values for each analysis","title":"Graphical testing for group sequential design","text":"analyses yet performed enter dummy values, including p-value near 1 (e.g., .99). entry required user section document. Calendar timing also associated PFS hypotheses use spending functions. Spending time OS spending input NULL spending based event counts OS hypotheses. DUMMY RESULTS IA2.","code":"### THIS NEEDS TO BE MODIFIED TO MATCH YOUR STUDY inputResults <- tibble(   H = c(rep(1, 3), rep(2, 3), rep(3, 2), rep(4, 2), 5, 6),   Pop = c(     rep(\"Subgroup\", 3), rep(\"All\", 3),     rep(\"Subgroup\", 2), rep(\"All\", 2),     \"Subgroup\", \"All\"   ),   Endpoint = c(rep(\"OS\", 6), rep(\"PFS\", 4), rep(\"ORR\", 2)),   # Example with some rejections   nominalP = c(     .03, .0001, .000001,     .2, .15, .1,     .2, .001,     .3, .2,     .00001,     .1   ),   # Example with no rejections   # nominalP = rep(.03, 12),   Analysis = c(1:3, 1:3, 1:2, 1:2, 1, 1),   events = c(ossub$n.I, os$n.I, pfssub$n.I, pfs$n.I, NA, NA),   spendingTime = c(     ossub$n.I / max(ossub$n.I),     ossub$n.I / max(ossub$n.I),     pfssub$n.I / max(pfssub$n.I),     pfssub$n.I / max(pfssub$n.I),     NA, NA   ) ) kable(inputResults, caption = \"DUMMY RESULTS FOR IA2.\") %>%   kable_styling() %>%   add_footnote(\"Dummy results\", notation = \"none\")"},{"path":[]},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"compute-sequential-p-values-for-each-hypothesis","dir":"Articles","previous_headings":"Testing hypotheses","what":"Compute sequential p-values for each hypothesis","title":"Graphical testing for group sequential design","text":"Sequential p-value computation done one loop attempt minimize chances coding errors. delay showing display sequence multiplicity graphs generated hypothesis rejection shown.","code":"### USER SHOULD NOT NEED TO MODIFY THIS CODE EOCtab <- NULL EOCtab <- inputResults %>%   group_by(H) %>%   slice(1) %>%   ungroup() %>%   select(\"H\", \"Pop\", \"Endpoint\", \"nominalP\") EOCtab$seqp <- .9999 for (EOCtabline in 1:nHypotheses) {   EOCtab$seqp[EOCtabline] <-     ifelse(is.null(gsDlist[[EOCtabline]]), EOCtab$nominalP[EOCtabline], {       tem <- filter(inputResults, H == EOCtabline)       sequentialPValue(         gsD = gsDlist[[EOCtabline]], interval = c(.0001, .9999),         n.I = tem$events,         Z = -qnorm(tem$nominalP),         usTime = tem$spendingTime       )     }) } EOCtab <- EOCtab %>% select(-\"nominalP\") # kable(EOCtab,caption=\"Sequential p-values as initially placed in EOCtab\") %>% kable_styling()"},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"evaluate-hypothesis-rejection-using-gmcplite","dir":"Articles","previous_headings":"Testing hypotheses","what":"Evaluate hypothesis rejection using gMCPLite","title":"Graphical testing for group sequential design","text":"need set graph object implemented gMCPLite package. Now add sequential p-values evaluate hypotheses rejected.","code":"# Make a graph object rownames(m) <- nameHypotheses graph <- matrix2graph(m) # Add weights to the object based on alpha allocation graph <- setWeights(graph, alphaHypotheses / fwer) rescale <- 45 d <- g$layers[[2]]$data rownames(d) <- rownames(m) # graph@nodeAttr$X <- rescale * d$x * 1.75 # graph@nodeAttr$Y <- -rescale * d$y * 2 result <- gMCP(graph = graph, pvalues = EOCtab$seqp, alpha = fwer) result@rejected #>      H1: OS\\n Subgroup  H2: OS\\n All subjects     H3: PFS\\n Subgroup  #>                   TRUE                  FALSE                   TRUE  #> H4: PFS\\n All subjects     H5: ORR\\n Subgroup H6: ORR\\n All subjects  #>                  FALSE                   TRUE                  FALSE # now map back into EOCtable (CHECK AGAIN!!!) EOCtab$Rejected <- result@rejected EOCtab$adjPValues <- result@adjPValues"},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"verification-of-hypotheses-rejected","dir":"Articles","previous_headings":"","what":"Verification of hypotheses rejected","title":"Graphical testing for group sequential design","text":"","code":"# Number of graphs is used repeatedly ngraphs <- length(result@graphs) # Set up tibble with hypotheses rejected at each stage rejected <- NULL for (i in 1:length(result@graphs)) {   rejected <- rbind(     rejected,     tibble(       H = 1:nHypotheses, Stage = i,       Rejected = as.logical(result@graphs[[i]]@nodeAttr$rejected)     )   ) } rejected <- rejected %>%   filter(Rejected) %>%   group_by(H) %>%   summarize(graphRejecting = min(Stage) - 1, .groups = \"drop\") %>% # Last graph with weight>0 where H rejected   arrange(graphRejecting)  # Get final weights # for hypotheses not rejected, this will be final weight where # no hypothesis could be rejected lastWeights <- as.numeric(result@graphs[[ngraphs]]@weights) lastGraph <- rep(ngraphs, nrow(EOCtab))  # We will update for rejected hypotheses with last positive weight for each if (ngraphs > 1) {   for (i in 1:(ngraphs - 1)) {     lastWeights[rejected$H[i]] <- as.numeric(result@graphs[[i]]@weights[rejected$H[i]])     lastGraph[rejected$H[i]] <- i   } } EOCtab$lastAlpha <- fwer * lastWeights EOCtab$lastGraph <- lastGraph EOCtabx <- EOCtab names(EOCtabx) <- c(   \"Hypothesis\", \"Population\", \"Endpoint\", \"Sequential p\",   \"Rejected\", \"Adjusted p\", \"Max alpha allocated\", \"Last Graph\" ) # Display table with desired column order # Delayed following until after multiplicity graph sequence # EOCtabx %>% select(c(1:4,7,5:6,8)) %>% kable() %>% kable_styling()"},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"multiplicity-graph-sequence-from-gmcplite","dir":"Articles","previous_headings":"Verification of hypotheses rejected","what":"Multiplicity graph sequence from gMCPLite","title":"Graphical testing for group sequential design","text":"### NEED MODIFY CODE SECTION (1:ngraphs) {   mx <- result@graphs[[]]@m   rownames(mx) <- NULL   colnames(mx) <- NULL   g <- gMCPLite::hGraph(     nHypotheses = nHypotheses,     alphaHypotheses = result@graphs[[]]@weights * fwer,     m = mx,     nameHypotheses = nameHypotheses,     palette = cbPalette,     halfWid = 1, halfHgt = .35, xradius = 2.5, yradius = 1, offset = 0, trhw = .15,     x = c(-1.25, 1.25, -2.5, 2.5, -1.25, 1.25), y = c(2, 2, 1, 1, 0, 0),     trprop = .4, fill = .character(c(2, 2, 4, 4, 3, 3))   )    cat(\" \\n\")   cat(\"####\", paste(\" Graph\", .character(), \" \\n\\n\"))   print(g)   cat(\" \\n\\n\\n\") } Graph 1 Graph 2 Graph 3 Graph 4","code":""},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"comparison-of-sequential-p-values-to-multiplicity-graphs","dir":"Articles","previous_headings":"Verification of hypotheses rejected","what":"Comparison of sequential p-values to multiplicity graphs","title":"Graphical testing for group sequential design","text":"can compare sequential p-values available \\(\\alpha\\) graph. column ‘Last Graph’ can see one 2 things: rejected hypotheses, maximum \\(\\alpha\\) allocated hypothesis. example, hypothesis one allocated \\(\\alpha=0.01\\) first graph (select using first tab). see sequential p-value 0.0001 smaller \\(\\alpha=0.01\\) thus hypothesis rejected. can proceed second graph see hypothesis 5 rejected. last hypothesis rejected hypothesis 3 third graph. remaining hypotheses (H2, H4, H6) maximum \\(\\alpha\\) allocated fourth graph; since sequential p-value greater allocated \\(\\alpha\\) corresponding hypothesis, none hypotheses rejected.","code":"EOCtabx %>%   select(c(1:4, 7, 5:6, 8)) %>%   kable() %>%   kable_styling()"},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"bounds-at-final-alpha-allocated-for-group-sequential-tests","dir":"Articles","previous_headings":"Verification of hypotheses rejected","what":"Bounds at final \\(\\alpha\\) allocated for group sequential tests","title":"Graphical testing for group sequential design","text":"separate validation, examine group sequential bounds hypothesis updated 1) maximum \\(\\alpha\\) allocated , 2) number events analysis, 3) cumulative spending analysis . nominal p-value least one analyses performed rejected hypotheses less equal nominal p-value group sequential design. hypothesis rejected, nominal p-values greater corresponding bound. hypotheses tested without group sequential design, nominal p-value test hypothesis can compared maximum alpha allocated table. (1:nHypotheses) {   # Set tab hypothesis output   cat(\"####\", paste(\" Hypothesis\", .character(), \" \\n\"))   # Get results hypothesis   hresults <- inputResults %>% filter(H == )   # Print max alpha allocated   xx <- paste(\"Max alpha allocated table: \",     .character(EOCtab$lastAlpha[]),     sep = \"\"   )   d <- gsDlist[[]]   # group sequential hypothesis, print max alpha allocated   # nominal p-value   (.null(d)) {     cat(\"Maximum alpha allocated: \")     cat(EOCtab$lastAlpha[])     cat(\"\\n\\n\")     cat(\"Nominal p-value hypothesis test: \")     cat(hresults$nominalP)     cat(\"\\n\\n\")   }   # group sequential tests, print max alpha allocated   # corresponding group sequential bounds   (!.null(gsDlist[[]])) {     cat(\"Nominal p-values analysis comparison bounds table :\\n\\n\")     cat(hresults$nominalP)     cat(\"\\n\\n\")     # Get info current hypothesis     n.<- hresults$events     usTime <- hresults$spendingTime     n.Iplan <- max(d$n.)     (length(n.) == 1) {       n.<- c(n., n.Iplan)       usTime <- c(usTime, 1)     }     # alpha allocated, just print text line note along 0 alpha allocated     (EOCtab$lastAlpha[] == 0) {       cat(\"Maximum alpha allocated: 0\\n\\n\")       cat(\"testing required\\n\\n\")     }     (EOCtab$lastAlpha[] > 0) {       dupdate <- gsDesign::gsDesign(         alpha = EOCtab$lastAlpha[],         k = length(n.),         n.= n.,         usTime = usTime,         maxn.IPlan = n.Iplan,         n.fix = d$n.fix,         test.type = 1,         sfu = d$upper$sf,         sfupar = d$upper$param       )       tabl <- gsDesign::gsBoundSummary(dupdate,         Nname = \"Events\",         exclude = c(           \"B-value\", \"CP\", \"CP H1\", \"Spending\",           \"~delta bound\", \"P(Cross) delta=0\",           \"PP\", \"P(Cross) delta=1\"         )       )       kable(tabl, caption = xx, row.names = FALSE) %>%         kable_styling() %>%         cat()       cat(\"\\n\\n\")     }   } } Hypothesis 1 Hypothesis 2 Hypothesis 3 Hypothesis 4 Hypothesis 5 Hypothesis 6 Nominal p-values analysis comparison bounds table : 0.03 0.0001 0.000001 Max alpha allocated table: 0.01 Nominal p-values analysis comparison bounds table : 0.2 0.15 0.1 Max alpha allocated table: 0.02 Nominal p-values analysis comparison bounds table : 0.2 0.001 Max alpha allocated table: 0.004 Nominal p-values analysis comparison bounds table : 0.3 0.2 Max alpha allocated table: 0.004 Maximum alpha allocated: 0.0005 Nominal p-value hypothesis test: 0.00001 Maximum alpha allocated: 0.001 Nominal p-value hypothesis test: 0.1","code":"# Restore default options options(old)"},{"path":"https://merck.github.io/gMCPLite/articles/GraphicalMultiplicity.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Graphical testing for group sequential design","text":"can use sessionInfo() document versions R R packages used render document. Note, particular, version 3.1 later gsDesign package needed.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/articles/hGraph.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Multiplicity graphs","text":"gsDesign version 3.1, added function support graphical multiplicity methods using ggplot2, function migrated gMCPLite package now. graphical method introduced nicely Bretz et al. (2011) originally supported gMCP packages (Rohmeyer Klinglmueller (2020)), now gMCPLite package. extended group sequential design Maurer Bretz (2013). gMCPLite package supports graphics, add hGraph() function create multiplicity graphs using ggplot2 package convenience desiring format. demonstrate basic formatting article demonstrate use gMCPLite article. Use hGraph() organized follows: basic graph layout Specifying hypothesis names \\(\\alpha\\)-allocation Text formatting location, ellipse size Specifying transition matrix hypotheses Using colors legends","code":""},{"path":"https://merck.github.io/gMCPLite/articles/hGraph.html","id":"the-basic-graph-layout","dir":"Articles","previous_headings":"","what":"The basic graph layout","title":"Multiplicity graphs","text":"begin default plot demonstrate basic formatting . Hypthoses initial \\(\\alpha\\)-allocation weighting presented shaded ellipses first hyothesis specified upper-left part plot. user full control ellipse placement color, default present clockwise larger ellipse gray shading. One advantage default placement generally transition lines hypotheses cross hypothesis ellipses, including graph updated hypotheses rejected. Transition weights hypotheses specified directional lines hypothesis ellipses. Try plot window. Note effect change size plot window. similar fashion, using R Markdown, parameters like fig.width, fig.height, fig.asp affect formatting.","code":"hGraph()"},{"path":"https://merck.github.io/gMCPLite/articles/hGraph.html","id":"specifying-hypothesis-names-and-alpha-allocation","dir":"Articles","previous_headings":"","what":"Specifying hypothesis names and \\(\\alpha\\)-allocation","title":"Multiplicity graphs","text":"Next specify number hypotheses, hypothesis names \\(\\alpha\\)-allocation weighting. Whereas default plot used \\(\\alpha\\)-allocation adding 0.025, use weights adding 1. Note \\n character used insert carriage return hypothesis name text. character used weights (specified wchar) default \\(\\alpha\\) Windows w otherwise. Note clockwise placement hypotheses.","code":"hGraph(   nHypotheses = 3,   nameHypotheses = c(\"HA\\n First\", \"HC\\n Second\", \"HB\\n Third\"),   alphaHypotheses = c(.2, .3, .5),   wchar = \"w\" # Character before weights )"},{"path":"https://merck.github.io/gMCPLite/articles/hGraph.html","id":"text-formatting-and-location-ellipse-size","dir":"Articles","previous_headings":"","what":"Text formatting and location, ellipse size","title":"Multiplicity graphs","text":"can specify location hypothesis ellipses two ways. first, specify radians large ellipse first hypothesis placed. Setting \\(\\pi/2\\) radianStart places first hypothesis center top plot (left plot). Specifying x y coordinates, right graph, allows custom placement; note differences minimum maximum x- y-values use well window size impact formatting. Ellipse text size well maximum significant digits hypotheses controlled follows: Size text hypothesis ellipses controlled size parameter (left graph). text always placed center ellipse user control. Size ellipses controlled halfWid (left graph) halfHgt (shown; default 0.5) parameters. digits specifies maximum digits \\(\\alpha\\)-allocation (shown ; default 5) Box text size well maximum significant digit display transition weights controlled follows: boxtextsize (right graph) controls text size transition weights trhw (left graph) controls half-width transition box size trhh (shown; default 0.075) controls half-height transition box size trprop (right graph) specifies proportional placement transition weight boxes along transition lines present, transitions arrowsize (left plot) controls size arrows ellipses parameter shown offset (left graph). radians; increases decreases offset transition lines hypothesis ellipses. transition arrows directions pair hypotheses, offset = 0 reasonable option.","code":"grid.arrange(   # Left graph in figure   hGraph(     nHypotheses = 3,     size = 5, # Decrease hypothesis text size from default 6     halfWid = 1.25, # Increase ellipse width from default 0.5     trhw = 0.25, # Increase transition box sizes from default 0.075     radianStart = pi / 2, # First hypothesis top middle     offset = pi / 20, # Decrease offset between transition lines     arrowsize = .03 # Increase from default 0.02   ),   # Right graph in figure   hGraph(     nHypotheses = 3,     x = c(-1, 1, -1), # Custom placement using x and y     y = c(1, 1, -1),     halfWid = 0.7, # Increase ellipse width from default 0.5     boxtextsize = 3, # Decrease box text size from default 4     trprop = .15 # Slide transition boxes closer to initiating hypothesis   ),   nrow = 1 )"},{"path":"https://merck.github.io/gMCPLite/articles/hGraph.html","id":"using-colors-and-legends","dir":"Articles","previous_headings":"","what":"Using colors and legends","title":"Multiplicity graphs","text":"default color palette ellipse shading monochrome (left plot ). limit parameters used, adjusted text, ellipse box size . Colors specified follows: fill color category; group first 2 hypotheses last 2 hypotheses (graphs) palette specifies palette colors (right graph)  Next, add legend. legend added default legend.positon = \"none\" replaced. use custom position specifying relative postioning (0,1) scale x- y-range graph. Commonly used options \"left\", \"right\", \"top\", ’“bottom”` legend.name (default none) specifies name legend labels specifies labels corresponding fill parameter","code":"grid.arrange(   # Left graph in figure   hGraph(     fill = c(1, 1, 2, 2),     alphaHypotheses = c(.2, .2, .2, .4) * .025   ),   # Right graph in figure   hGraph(     fill = c(1, 1, 2, 2),     palette = c(\"pink\", \"lightblue\"),     alphaHypotheses = c(.2, .2, .2, .4) * .025   ),   nrow = 1 ) hGraph(   nHypotheses = 3,   fill = c(1, 1, 2),   palette = c(\"yellow\", \"lightblue\"),   legend.name = \"Color scheme\",   labels = c(\"Primary\", \"Secondary\"),   legend.position = c(.75, .25) )"},{"path":"https://merck.github.io/gMCPLite/articles/hGraph.html","id":"specifying-the-transition-matrix-between-hypotheses","dir":"Articles","previous_headings":"","what":"Specifying the transition matrix between hypotheses","title":"Multiplicity graphs","text":"Transition weights specified matrix format variable m. matrix must square dimension nHypotheses 0 diagonal. Rows represent hypotheses transitions start; row values sum 1. Columns represent hypotheses transition arrows go. transition weight 0 corresponding transition line figure.","code":"hGraph(   nHypotheses = 3,   m = matrix(c(     0, 1, 0,     .2, 0, .8,     .3, .7, 0   ),   nrow = 3, byrow = TRUE   ), )"},{"path":[]},{"path":"https://merck.github.io/gMCPLite/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yalin Zhu. Author, maintainer. Yilong Zhang. Author. Xuan Deng. Author. Keaven Anderson. Author. Nan Xiao. Author. Kornelius Rohmeyer. Contributor.            gMCP author Florian Klinglmueller. Contributor.            gMCP author gMCP project contributors. Copyright holder.            gMCP package Merck & Co., Inc., Rahway, NJ, USA affiliates. Copyright holder.","code":""},{"path":"https://merck.github.io/gMCPLite/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Zhu Y, Zhang Y, Deng X, Anderson K, Xiao N (2022). gMCPLite: Lightweight Graph Based Multiple Comparison Procedures. https://merck.github.io/gMCPLite/, https://github.com/Merck/gMCPLite.","code":"@Manual{,   title = {gMCPLite: Lightweight Graph Based Multiple Comparison Procedures},   author = {Yalin Zhu and Yilong Zhang and Xuan Deng and Keaven Anderson and Nan Xiao},   year = {2022},   note = {https://merck.github.io/gMCPLite/, https://github.com/Merck/gMCPLite}, }"},{"path":"https://merck.github.io/gMCPLite/index.html","id":"gmcplite-","dir":"","previous_headings":"","what":"Lightweight Graph Based Multiple Comparison Procedures","title":"Lightweight Graph Based Multiple Comparison Procedures","text":"gMCPLite fork gMCP graph-based multiple comparison procedures, following features: Kept selected subset original functions. Removed rJava dependency Java-based graphical interface. Added hGraph() function ggplot2 visualizations. bridges gMCP result objects gsDesign produce multiple comparison graphs sequential graph updates.","code":""},{"path":"https://merck.github.io/gMCPLite/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Lightweight Graph Based Multiple Comparison Procedures","text":"","code":"# The easiest way to get gMCPLite is to install: install.packages(\"gMCPLite\")  # Alternatively, install development version from GitHub: # install.packages(\"remotes\") remotes::install_github(\"Merck/gMCPLite\")"},{"path":"https://merck.github.io/gMCPLite/reference/bdiagNA.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Block Diagonal Matrix with NA outside the diagonal — bdiagNA","title":"Create a Block Diagonal Matrix with NA outside the diagonal — bdiagNA","text":"Build block diagonal matrix NA values outside diagonal given several building block matrices.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bdiagNA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Block Diagonal Matrix with NA outside the diagonal — bdiagNA","text":"","code":"bdiagNA(...)"},{"path":"https://merck.github.io/gMCPLite/reference/bdiagNA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Block Diagonal Matrix with NA outside the diagonal — bdiagNA","text":"... individual matrices list matrices.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bdiagNA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Block Diagonal Matrix with NA outside the diagonal — bdiagNA","text":"block diagonal matrix NA values outside diagonal.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bdiagNA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Block Diagonal Matrix with NA outside the diagonal — bdiagNA","text":"function usefull build correlation matrices, partial knowledge correlation exists.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/bdiagNA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Block Diagonal Matrix with NA outside the diagonal — bdiagNA","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bdiagNA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Block Diagonal Matrix with NA outside the diagonal — bdiagNA","text":"","code":"bdiagNA(diag(3), matrix(1/2,nr=3,nc=3), diag(2)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    0    0   NA   NA   NA   NA   NA #> [2,]    0    1    0   NA   NA   NA   NA   NA #> [3,]    0    0    1   NA   NA   NA   NA   NA #> [4,]   NA   NA   NA  0.5  0.5  0.5   NA   NA #> [5,]   NA   NA   NA  0.5  0.5  0.5   NA   NA #> [6,]   NA   NA   NA  0.5  0.5  0.5   NA   NA #> [7,]   NA   NA   NA   NA   NA   NA    1    0 #> [8,]   NA   NA   NA   NA   NA   NA    0    1"},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Weighted Bonferroni-test — bonferroni.test","title":"Weighted Bonferroni-test — bonferroni.test","text":"Weighted Bonferroni-test","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weighted Bonferroni-test — bonferroni.test","text":"","code":"bonferroni.test(   pvalues,   weights,   alpha = 0.05,   adjPValues = TRUE,   verbose = FALSE,   ... )"},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weighted Bonferroni-test — bonferroni.test","text":"pvalues numeric vector specifying p-values. weights numeric vector weights. alpha numeric specifying maximal allowed type one error rate. adjPValues==TRUE (default) parameter alpha used. adjPValues Logical scalar. TRUE (default) adjusted p-value weighted Bonferroni-test returned. Otherwise adjPValues==FALSE logical value returned whether null hypothesis can rejected. verbose Logical scalar. TRUE verbose output generated. ... arguments possibly passed gMCP used test procedures one.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weighted Bonferroni-test — bonferroni.test","text":"adjusted p-value decision rejection","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weighted Bonferroni-test — bonferroni.test","text":"","code":"bonferroni.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0)) #> [1] 0.2 bonferroni.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE) #> [1] FALSE"},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.trimmed.simes.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test — bonferroni.trimmed.simes.test","title":"Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test — bonferroni.trimmed.simes.test","text":"Trimmed Simes test intersections two hypotheses otherwise weighted Bonferroni-test","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.trimmed.simes.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test — bonferroni.trimmed.simes.test","text":"","code":"bonferroni.trimmed.simes.test(   pvalues,   weights,   alpha = 0.05,   adjPValues = FALSE,   verbose = FALSE,   ... )"},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.trimmed.simes.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test — bonferroni.trimmed.simes.test","text":"pvalues numeric vector specifying p-values. weights numeric vector weights. alpha numeric specifying maximal allowed type one error rate. adjPValues==TRUE (default) parameter alpha used. adjPValues Logical scalar. TRUE (default) adjusted p-value weighted test returned. Otherwise adjPValues==FALSE logical value returned whether null hypothesis can rejected. verbose Logical scalar. TRUE verbose output generated. ... arguments possibly passed gMCP used test procedures one.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.trimmed.simes.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test — bonferroni.trimmed.simes.test","text":"adjusted p-value decision rejection","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.trimmed.simes.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test — bonferroni.trimmed.simes.test","text":"Brannath, W., Bretz, F., Maurer, W., & Sarkar, S. (2009). Trimmed Weighted Simes Test Two One-Sided Hypotheses Arbitrarily Correlated Test Statistics. Biometrical Journal, 51(6), 885-898.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/bonferroni.trimmed.simes.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test — bonferroni.trimmed.simes.test","text":"","code":"bonferroni.trimmed.simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0)) #> [1] FALSE bonferroni.trimmed.simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE) #> [1] FALSE"},{"path":"https://merck.github.io/gMCPLite/reference/checkCorrelation.html","id":null,"dir":"Reference","previous_headings":"","what":"Check correlation matrix — checkCorrelation","title":"Check correlation matrix — checkCorrelation","text":"Sanity checks correlation matrix.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/checkCorrelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check correlation matrix — checkCorrelation","text":"","code":"checkCorrelation(m, returnMessage = FALSE, na.allowed = TRUE)"},{"path":"https://merck.github.io/gMCPLite/reference/checkCorrelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check correlation matrix — checkCorrelation","text":"m TBA returnMessage TBA na.allowed TBA","code":""},{"path":"https://merck.github.io/gMCPLite/reference/checkCorrelation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check correlation matrix — checkCorrelation","text":"Logical","code":""},{"path":"https://merck.github.io/gMCPLite/reference/checkCorrelation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check correlation matrix — checkCorrelation","text":"Checks following properties: Values must -1 1. Diagonal must equal 1. Matrix must symmetric.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/checkCorrelation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check correlation matrix — checkCorrelation","text":"","code":"NULL #> NULL"},{"path":"https://merck.github.io/gMCPLite/reference/entangledMCP-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class entangledMCP — entangledMCP-class","title":"Class entangledMCP — entangledMCP-class","text":"entangledMCP object describes ... TODO","code":""},{"path":"https://merck.github.io/gMCPLite/reference/entangledMCP-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class entangledMCP — entangledMCP-class","text":"subgraphs list graphs class graphMCP. weights numeric. graphAttr list graph attributes like color, etc.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/entangledMCP-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class entangledMCP — entangledMCP-class","text":"print signature(object = \"entangledMCP\"): method printing data entangled graph R console. getMatrices signature(object = \"entangledMCP\"): method getting list transition matrices entangled graph. getWeights signature(object = \"entangledMCP\"): method getting matrix weights entangled graph. getRejected signature(object = \"entangledMCP\"):       method getting information whether hypotheses marked graph already rejected.     second optional argument node specified, nodes boolean vector returned. getXCoordinates signature(object = \"entangledMCP\"):       method getting x coordinates graph.     second optional argument node specified, nodes x coordinates returned.     x coordinates yet set, NULL returned. getYCoordinates signature(object = \"entangledMCP\"):       method getting y coordinates graph     second optional argument node specified, nodes x coordinates returned.     y coordinates yet set, NULL returned.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/entangledMCP-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class entangledMCP — entangledMCP-class","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/entangledMCP-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class entangledMCP — entangledMCP-class","text":"","code":"g1 <- BonferroniHolm(2) g2 <- BonferroniHolm(2)  graph <- new(\"entangledMCP\", subgraphs=list(g1,g2), weights=c(0.5,0.5))  getMatrices(graph) #> [[1]] #>    H1 H2 #> H1  0  1 #> H2  1  0 #>  #> [[2]] #>    H1 H2 #> H1  0  1 #> H2  1  0 #>  getWeights(graph) #>       H1  H2 #> [1,] 0.5 0.5 #> [2,] 0.5 0.5"},{"path":"https://merck.github.io/gMCPLite/reference/exampleGraphs.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions that create different example graphs — exampleGraphs","title":"Functions that create different example graphs — exampleGraphs","text":"Functions creates example graphs, e.g. graphs represents Bonferroni-Holm adjustment, parallel gatekeeping special procedures selected papers.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/exampleGraphs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions that create different example graphs — exampleGraphs","text":"","code":"BonferroniHolm(n, weights = rep(1/n, n))  BretzEtAl2011()  BauerEtAl2001()  BretzEtAl2009a()  BretzEtAl2009b()  BretzEtAl2009c()  HommelEtAl2007()  HommelEtAl2007Simple()  parallelGatekeeping()  improvedParallelGatekeeping()  fallback(weights)  fixedSequence(n)  simpleSuccessiveI()  simpleSuccessiveII()  truncatedHolm(gamma)  generalSuccessive(weights = c(1/2, 1/2), gamma, delta)  HuqueAloshEtBhore2011()  HungEtWang2010(nu, tau, omega)  MaurerEtAl1995()  cycleGraph(nodes, weights)  improvedFallbackI(weights = rep(1/3, 3))  improvedFallbackII(weights = rep(1/3, 3))  FerberTimeDose2011(times, doses, w = \"\\\\nu\")  Ferber2011(w)  Entangled1Maurer2012()  Entangled2Maurer2012()  WangTing2014(nu, tau)"},{"path":"https://merck.github.io/gMCPLite/reference/exampleGraphs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions that create different example graphs — exampleGraphs","text":"n Number hypotheses. weights Numeric vector node weights. gamma optional number [0,1] specifying value variable gamma. delta optional number [0,1] specifying value variable delta. nu optional number [0,1] specifying value variable nu. tau optional number [0,1] specifying value variable tau. omega optional number [0,1] specifying value variable omega. nodes Character vector node names. times Number time points. doses Number dose levels. w variable weight(s) graph.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/exampleGraphs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functions that create different example graphs — exampleGraphs","text":"graph class graphMCP represents sequentially rejective multiple test procedure.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/exampleGraphs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functions that create different example graphs — exampleGraphs","text":"providing functions resulting graphs directly way additional examples: can look function body body see graph built. list(\"BonferroniHolm\") Returns graph represents Bonferroni-Holm adjustment.  result complete graph, nodes weights edge weight \\(\\frac{1}{n-1}\\). list(\"BretzEtAl2011\") Graph figure 2 Bretz et al. See references (Bretz et al. 2011). list(\"HommelEtAl2007\") Graph Hommel et al. See references (Hommel et al. 2007). list(\"parallelGatekeeping\") Graph parallel gatekeeping. See references (Dmitrienko et al. 2003). list(\"improvedParallelGatekeeping\") Graph improved parallel gatekeeping. See references (Hommel et al. 2007). list(\"HungEtWang2010\") Graph Hung et Wang. See references (Hung et Wang 2010). list(\"MaurerEtAl1995\") Graph Maurer et al. See references (Maurer et al. 1995). list(\"cycleGraph\") Cycle graph. weight weights[] specifies edge weight node \\(\\) node \\(+1\\) \\(=1,\\ldots,n-1\\) weight[n] node \\(n\\) node 1. list(\"improvedFallbackI\") Graph improved Fallback Procedure Wiens & Dmitrienko. See references (Wiens et Dmitrienko 2005). list(\"improvedFallbackII\") Graph improved Fallback Procedure Hommel & Bretz. See references (Hommel et Bretz 2008). list(\"Ferber2011\") Graph Ferber et al. See references (Ferber et al. 2011). list(\"FerberTimeDose2011\") Graph Ferber et al. See references (Ferber et al. 2011). list(\"Entangled1Maurer2012\") Entangled graph Maurer et al. TODO: Add references soon available.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/exampleGraphs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Functions that create different example graphs — exampleGraphs","text":"Holm, S. (1979). simple sequentally rejective multiple test procedure. Scandinavian Journal Statistics 6, 65-70. Dmitrienko, ., Offen, W., Westfall, P.H. (2003). Gatekeeping strategies clinical trials require primary effects significant. Statistics Medicine. 22, 2387-2400. Bretz, F., Maurer, W., Brannath, W., Posch, M.: graphical approach sequentially rejective multiple test procedures. Statistics Medicine 2009 vol. 28 issue 4 page 586-604. http://www.meduniwien.ac./fwf_adaptive/papers/bretz_2009_22.pdf Bretz, F., Maurer, W. Hommel, G. (2011), Test power considerations multiple endpoint analyses using sequentially rejective graphical procedures. Statistics Medicine, 30: 1489--1501. Hommel, G., Bretz, F. und Maurer, W. (2007). Powerful short-cuts multiple testing procedures special reference gatekeeping strategies. Statistics Medicine, 26(22), 4063-4073. Hommel, G., Bretz, F. (2008): Aesthetics power considerations multiple testing - contradiction? Biometrical Journal 50:657-666. Hung H.M.J., Wang S.-J. (2010). Challenges multiple testing clinical trials. Biometrical Journal 52, 747-756. W. Maurer, L. Hothorn, W. Lehmacher: Multiple comparisons drug clinical trials preclinical assays: -priori ordered hypotheses. Biometrie der chemisch-pharmazeutischen Industrie, Vollmar J (ed.). Fischer Verlag: Stuttgart, 1995; 3-18. Maurer, W., & Bretz, F. (2013). Memory properties multiple test procedures generated entangled graphs. Statistics medicine, 32 (10), 1739-1753. Wiens, B.L., Dmitrienko, . (2005): fallback procedure evaluating single family hypotheses. Journal Biopharmaceutical Statistics 15:929-942. Wang, B., Ting, N. (2014). Application Graphical Approach Construct Multiple Testing Procedures Hypothetical Phase III Design. Frontiers public health, 1 (75). Ferber, G. Staner, L. Boeijinga, P. (2011): Structured multiplicity confirmatory statistical analyses pharmacodynamic studies using quantitative electroencephalogram, Journal neuroscience methods, Volume 201, Issue 1, Pages 204-212.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/exampleGraphs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Functions that create different example graphs — exampleGraphs","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/exampleGraphs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functions that create different example graphs — exampleGraphs","text":"","code":"g <- BonferroniHolm(5)  gMCP(g, pvalues=c(0.1, 0.2, 0.4, 0.4, 0.7)) #> gMCP-Result #>  #> Initial graph: #> A graphMCP graph #> H1 (weight=0.2) #> H2 (weight=0.2) #> H3 (weight=0.2) #> H4 (weight=0.2) #> H5 (weight=0.2) #> Edges: #> H1  -( 0.25 )->  H2  #> H1  -( 0.25 )->  H3  #> H1  -( 0.25 )->  H4  #> H1  -( 0.25 )->  H5  #> H2  -( 0.25 )->  H1  #> H2  -( 0.25 )->  H3  #> H2  -( 0.25 )->  H4  #> H2  -( 0.25 )->  H5  #> H3  -( 0.25 )->  H1  #> H3  -( 0.25 )->  H2  #> H3  -( 0.25 )->  H4  #> H3  -( 0.25 )->  H5  #> H4  -( 0.25 )->  H1  #> H4  -( 0.25 )->  H2  #> H4  -( 0.25 )->  H3  #> H4  -( 0.25 )->  H5  #> H5  -( 0.25 )->  H1  #> H5  -( 0.25 )->  H2  #> H5  -( 0.25 )->  H3  #> H5  -( 0.25 )->  H4  #>  #>  #> P-values: #>  H1  H2  H3  H4  H5  #> 0.1 0.2 0.4 0.4 0.7  #>  #> Adjusted p-values: #>  H1  H2  H3  H4  H5  #> 0.5 0.8 1.0 1.0 1.0  #>  #> Alpha: 0.05  #>  #> No hypotheses could be rejected.  HungEtWang2010() #> A graphMCP graph #> H_{1,NI} (weight=1) #> H_{1,S} (weight=0) #> H_{2,NI} (weight=0) #> H_{2,S} (weight=0) #> Edges: #> H_{1,NI}  -( \\nu )->  H_{1,S}  #> H_{1,NI}  -( 1-\\nu )->  H_{2,NI}  #> H_{1,S}  -( \\tau )->  H_{2,NI}  #> H_{1,S}  -( 1-\\tau )->  H_{2,S}  #> H_{2,NI}  -( \\omega )->  H_{1,S}  #> H_{2,NI}  -( 1-\\omega )->  H_{2,S}  #>  HungEtWang2010(nu=1) #> A graphMCP graph #> H_{1,NI} (weight=1) #> H_{1,S} (weight=0) #> H_{2,NI} (weight=0) #> H_{2,S} (weight=0) #> Edges: #> H_{1,NI}  -( 1 )->  H_{1,S}  #> H_{1,NI}  -( 1-1 )->  H_{2,NI}  #> H_{1,S}  -( \\tau )->  H_{2,NI}  #> H_{1,S}  -( 1-\\tau )->  H_{2,S}  #> H_{2,NI}  -( \\omega )->  H_{1,S}  #> H_{2,NI}  -( 1-\\omega )->  H_{2,S}  #>"},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.extended.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph based Multiple Comparison Procedures — gMCP.extended","title":"Graph based Multiple Comparison Procedures — gMCP.extended","text":"Performs graph based multiple test procedure given graph unadjusted p-values.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.extended.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph based Multiple Comparison Procedures — gMCP.extended","text":"","code":"gMCP.extended(   graph,   pvalues,   test,   alpha = 0.05,   eps = 10^(-3),   upscale = FALSE,   verbose = FALSE,   adjPValues = TRUE,   ... )"},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.extended.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph based Multiple Comparison Procedures — gMCP.extended","text":"graph graph class graphMCP. pvalues numeric vector specifying p-values graph based MCP. Note assumptions description selected test (- example test=bonferroni.test assumptions, test=parametric.test assumes p-values multivariate normal distribution). test weighted test function. package gMCP provides following weighted test functions: bonferroni.test Bonferroni test - see ?bonferroni.test details. parametric.test Parametric test - see ?parametric.test details. simes.test Simes test - see ?simes.test details. bonferroni.trimmed.simes.test Trimmed Simes test intersections two hypotheses otherwise Bonferroni - see ?bonferroni.trimmed.simes.test details. simes..subsets.test Simes test intersections hypotheses certain sets otherwise Bonferroni - see ?simes..subsets.test details. provide test function see ?weighted.test.function. alpha numeric specifying maximal allowed type one error rate. eps numeric scalar specifying value epsilon edges. upscale Logical. upscale=FALSE intersection hypotheses (.e. subgraph) weighted test performed possibly reduced level alpha sum(w)*alpha, sum(w) sum node weights subset. upscale=TRUE weights upscaled, sum(w)=1. verbose Logical scalar. TRUE verbose output generated sequentially rejection steps. adjPValues Logical scalar. FALSE adjusted p-values calculated. Especially weighted Simes test result significantly less calculations cases. ... Test specific arguments can given .","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.extended.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph based Multiple Comparison Procedures — gMCP.extended","text":"object class gMCPResult, specifically list elements graphs list graphs pvalues p-values rejected logical whether hyptheses rejected adjPValues adjusted p-values","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.extended.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Graph based Multiple Comparison Procedures — gMCP.extended","text":"Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: graphical approach sequentially rejective multiple test procedures. Statistics Medicine 2009 vol. 28 issue 4 page 586-604. http://www.meduniwien.ac./fwf_adaptive/papers/bretz_2009_22.pdf Bretz F., Posch M., Glimm E., Klinglmueller F., Maurer W., Rohmeyer K. (2011): Graphical approaches multiple endpoint problems using weighted Bonferroni, Simes parametric tests. Biometrical Journal 53 (6), pages 894-913, Wiley. Strassburger K., Bretz F.: Compatible simultaneous lower confidence bounds Holm procedure Bonferroni based closed tests. Statistics Medicine 2008; 27:4914-4927. Hommel G., Bretz F., Maurer W.: Powerful short-cuts multiple testing procedures special reference gatekeeping strategies. Statistics Medicine 2007; 26:4063-4073. Guilbaud O.: Simultaneous confidence regions corresponding Holm's stepdown procedure closed-testing procedures. Biometrical Journal 2008; 50:678-692.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.extended.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Graph based Multiple Comparison Procedures — gMCP.extended","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.extended.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph based Multiple Comparison Procedures — gMCP.extended","text":"","code":"g <- BonferroniHolm(5) gMCP(g, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7)) #> gMCP-Result #>  #> Initial graph: #> A graphMCP graph #> H1 (weight=0.2) #> H2 (weight=0.2) #> H3 (weight=0.2) #> H4 (weight=0.2) #> H5 (weight=0.2) #> Edges: #> H1  -( 0.25 )->  H2  #> H1  -( 0.25 )->  H3  #> H1  -( 0.25 )->  H4  #> H1  -( 0.25 )->  H5  #> H2  -( 0.25 )->  H1  #> H2  -( 0.25 )->  H3  #> H2  -( 0.25 )->  H4  #> H2  -( 0.25 )->  H5  #> H3  -( 0.25 )->  H1  #> H3  -( 0.25 )->  H2  #> H3  -( 0.25 )->  H4  #> H3  -( 0.25 )->  H5  #> H4  -( 0.25 )->  H1  #> H4  -( 0.25 )->  H2  #> H4  -( 0.25 )->  H3  #> H4  -( 0.25 )->  H5  #> H5  -( 0.25 )->  H1  #> H5  -( 0.25 )->  H2  #> H5  -( 0.25 )->  H3  #> H5  -( 0.25 )->  H4  #>  #>  #> P-values: #>   H1   H2   H3   H4   H5  #> 0.01 0.02 0.04 0.04 0.70  #>  #> Adjusted p-values: #>   H1   H2   H3   H4   H5  #> 0.05 0.08 0.12 0.12 0.70  #>  #> Alpha: 0.05  #>  #> Hypothesis rejected: #>    H1    H2    H3    H4    H5  #>  TRUE FALSE FALSE FALSE FALSE  #>  #> Final graph after1steps: #> A graphMCP graph #> H1 (rejected, weight=0) #> H2 (weight=0.25) #> H3 (weight=0.25) #> H4 (weight=0.25) #> H5 (weight=0.25) #> Edges: #> H2  -( 0.333333333333333 )->  H3  #> H2  -( 0.333333333333333 )->  H4  #> H2  -( 0.333333333333333 )->  H5  #> H3  -( 0.333333333333333 )->  H2  #> H3  -( 0.333333333333333 )->  H4  #> H3  -( 0.333333333333333 )->  H5  #> H4  -( 0.333333333333333 )->  H2  #> H4  -( 0.333333333333333 )->  H3  #> H4  -( 0.333333333333333 )->  H5  #> H5  -( 0.333333333333333 )->  H2  #> H5  -( 0.333333333333333 )->  H3  #> H5  -( 0.333333333333333 )->  H4  #>  # Simple Bonferroni with empty graph: g2 <- matrix2graph(matrix(0, nrow=5, ncol=5)) gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7)) #> gMCP-Result #>  #> Initial graph: #> A graphMCP graph #> H1 (weight=0.2) #> H2 (weight=0.2) #> H3 (weight=0.2) #> H4 (weight=0.2) #> H5 (weight=0.2) #> No edges. #>  #>  #> P-values: #>   H1   H2   H3   H4   H5  #> 0.01 0.02 0.04 0.04 0.70  #>  #> Adjusted p-values: #>   H1   H2   H3   H4   H5  #> 0.05 0.10 0.20 0.20 1.00  #>  #> Alpha: 0.05  #>  #> Hypothesis rejected: #>    H1    H2    H3    H4    H5  #>  TRUE FALSE FALSE FALSE FALSE  #>  #> Final graph after1steps: #> A graphMCP graph #> Sum of weight: 0.8 #> H1 (rejected, weight=0) #> H2 (weight=0.2) #> H3 (weight=0.2) #> H4 (weight=0.2) #> H5 (weight=0.2) #> No edges. #>  # With 'upscale=TRUE' equal to BonferroniHolm: gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7), upscale=TRUE) #> gMCP-Result #>  #> Initial graph: #> A graphMCP graph #> H1 (weight=0.2) #> H2 (weight=0.2) #> H3 (weight=0.2) #> H4 (weight=0.2) #> H5 (weight=0.2) #> No edges. #>  #>  #> P-values: #>   H1   H2   H3   H4   H5  #> 0.01 0.02 0.04 0.04 0.70  #>  #> Adjusted p-values: #>   H1   H2   H3   H4   H5  #> 0.05 0.08 0.12 0.12 0.70  #>  #> Alpha: 0.05  #>  #> Hypothesis rejected: #>    H1    H2    H3    H4    H5  #>  TRUE FALSE FALSE FALSE FALSE  #>  #> Final graph after1steps: #> A graphMCP graph #> H1 (rejected, weight=0) #> H2 (weight=0.25) #> H3 (weight=0.25) #> H4 (weight=0.25) #> H5 (weight=0.25) #> No edges. #>   # Entangled graphs: g3 <- Entangled2Maurer2012() gMCP(g3, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7), correlation=diag(5)) #> gMCP-Result #>  #> Initial graph: #> An object of class \"entangledMCP\" #> Slot \"subgraphs\": #> [[1]] #> A graphMCP graph #> H1 (weight=1) #> H2 (weight=0) #> H3 (weight=0) #> H4 (weight=0) #> H5 (weight=0) #> Edges: #> H1  -( 1 )->  H3  #> H2  -( 1 )->  H5  #> H3  -( 1 )->  H4  #> H4  -( 1 )->  H2  #>  #>  #> [[2]] #> A graphMCP graph #> H1 (weight=0) #> H2 (weight=1) #> H3 (weight=0) #> H4 (weight=0) #> H5 (weight=0) #> Edges: #> H1  -( 1 )->  H4  #> H2  -( 1 )->  H3  #> H3  -( 1 )->  H5  #> H5  -( 1 )->  H1  #>  #>  #>  #> Slot \"weights\": #> [1] 0.5 0.5 #>  #> Slot \"graphAttr\": #> list() #>  #>  #> P-values: #>   H1   H2   H3   H4   H5  #> 0.01 0.02 0.04 0.04 0.70  #>  #> Adjusted p-values: #>     H1     H2     H3     H4     H5  #> 0.0199 0.0396 0.0400 0.0784 0.7000  #>  #> Alpha: 0.05  #>  #> Hypothesis rejected: #>    H1    H2    H3    H4    H5  #>  TRUE  TRUE  TRUE FALSE FALSE"},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph based Multiple Comparison Procedures — gMCP","title":"Graph based Multiple Comparison Procedures — gMCP","text":"Performs graph based multiple test procedure given graph unadjusted p-values.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph based Multiple Comparison Procedures — gMCP","text":"","code":"gMCP(   graph,   pvalues,   test,   correlation,   alpha = 0.05,   approxEps = TRUE,   eps = 10^(-3),   ...,   upscale = ifelse(missing(test) && !missing(correlation) || !missing(test) && test ==     \"Bretz2011\", TRUE, FALSE),   useC = FALSE,   verbose = FALSE,   keepWeights = FALSE,   adjPValues = TRUE )"},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph based Multiple Comparison Procedures — gMCP","text":"graph graph class graphMCP. pvalues numeric vector specifying p-values graph based MCP. Note assumptions details section parametric tests, correlation specified. test either \"Bonferroni\", \"Simes\" \"parametric\". specified default Bonferroni-based test procedure used correlation specified algorithm Bretz et al. 2011 correlation specified. test set \"Simes\" weighted Simes test performed subset hypotheses. correlation Optional correlation matrix.  weighted Simes test performed, checked whether type error rate can ensured warning given case.  parametric tests p-values must arise one-sided tests multivariate normal distributed test statistics correlation (partially) known. case weighted parametric closed test performed (also see generatePvals). Unknown values can set NA. (See details information) alpha numeric specifying maximal allowed type one error rate. approxEps boolean specifying whether epsilon values substituted value given parameter eps. eps numeric scalar specifying value epsilon edges. ... Test specific arguments can given . upscale Logical. upscale=FALSE intersection hypotheses (.e. subgraph) weighted test performed possibly reduced level alpha sum(w)*alpha, sum(w) sum node weights subset. upscale=TRUE weights upscaled, sum(w)=1. backward compatibility default value TRUE parameter test missing, parameter correlation specified test==\"Bretz2011\". useC Logical scalar. TRUE neither adjusted p-values intermediate graphs returned, calculation sped using code written C. CODE PRODUCTIVE USE YET!  approxEps FALSE graph contains epsilon edges, warning thrown useC ignored. verbose Logical scalar. TRUE verbose output generated. keepWeights Logical scalar. FALSE weight node without outgoing edges set 0 removed.  Otherwise keeps weight. adjPValues Logical scalar. FALSE adjusted p-values calculated.  Especially weighted Simes test result significantly less calculations cases.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph based Multiple Comparison Procedures — gMCP","text":"object class gMCPResult, specifically list elements graphs list graphs pvalues p-values rejected logical whether hyptheses rejected adjPValues adjusted p-values","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Graph based Multiple Comparison Procedures — gMCP","text":"Bonferroni procedure p-values can arise statistical test, improve test specifying correlation matrix, following assumptions apply: assumed global null hypothesis \\((\\Phi^{-1}(1-p_1),...,\\Phi^{-1}(1-p_m))\\) follow multivariate normal distribution correlation matrix correlation \\(\\Phi^{-1}\\) denotes inverse standard normal distribution function. example, case \\(p_1,..., p_m\\) raw p-values one-sided z-tests elementary hypotheses correlation z-test statistics generated overlap observations (e.g. comparison common control, group-sequential analyses etc.). application transformation \\(\\Phi^{-1}(1-p_i)\\) raw p-values two-sided test general lead multivariate normal distribution. Partial knowledge correlation matrix supported. correlation matrix passed numeric matrix elements form: \\(correlation[,] = 1\\) diagonal elements, \\(correlation[,j] = \\rho_{ij}\\), \\(\\rho_{ij}\\) known value correlation \\(\\Phi^{-1}(1-p_i)\\) \\(\\Phi^{-1}(1-p_j)\\) NA corresponding correlation unknown. example correlation[1,2]=0 indicates first second test statistic uncorrelated, whereas correlation[2,3] = NA means true correlation statistics two three unknown may take values -1 1. correlation specified complete blocks (ie.: cor(,j), cor(,j') !=j!=j' specified cor(j,j') specified well) otherwise corresponding intersection null hypotheses tests uniquely defined error returned. details see given references.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Graph based Multiple Comparison Procedures — gMCP","text":"Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: graphical approach sequentially rejective multiple test procedures. Statistics Medicine 2009 vol. 28 issue 4 page 586-604. http://www.meduniwien.ac./fwf_adaptive/papers/bretz_2009_22.pdf Bretz F., Posch M., Glimm E., Klinglmueller F., Maurer W., Rohmeyer K. (2011): Graphical approaches multiple endpoint problems using weighted Bonferroni, Simes parametric tests. Biometrical Journal 53 (6), pages 894-913, Wiley. Strassburger K., Bretz F.: Compatible simultaneous lower confidence bounds Holm procedure Bonferroni based closed tests. Statistics Medicine 2008; 27:4914-4927. Hommel G., Bretz F., Maurer W.: Powerful short-cuts multiple testing procedures special reference gatekeeping strategies. Statistics Medicine 2007; 26:4063-4073. Guilbaud O.: Simultaneous confidence regions corresponding Holm's stepdown procedure closed-testing procedures. Biometrical Journal 2008; 50:678-692.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Graph based Multiple Comparison Procedures — gMCP","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph based Multiple Comparison Procedures — gMCP","text":"","code":"g <- BonferroniHolm(5) gMCP(g, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7)) #> gMCP-Result #>  #> Initial graph: #> A graphMCP graph #> H1 (weight=0.2) #> H2 (weight=0.2) #> H3 (weight=0.2) #> H4 (weight=0.2) #> H5 (weight=0.2) #> Edges: #> H1  -( 0.25 )->  H2  #> H1  -( 0.25 )->  H3  #> H1  -( 0.25 )->  H4  #> H1  -( 0.25 )->  H5  #> H2  -( 0.25 )->  H1  #> H2  -( 0.25 )->  H3  #> H2  -( 0.25 )->  H4  #> H2  -( 0.25 )->  H5  #> H3  -( 0.25 )->  H1  #> H3  -( 0.25 )->  H2  #> H3  -( 0.25 )->  H4  #> H3  -( 0.25 )->  H5  #> H4  -( 0.25 )->  H1  #> H4  -( 0.25 )->  H2  #> H4  -( 0.25 )->  H3  #> H4  -( 0.25 )->  H5  #> H5  -( 0.25 )->  H1  #> H5  -( 0.25 )->  H2  #> H5  -( 0.25 )->  H3  #> H5  -( 0.25 )->  H4  #>  #>  #> P-values: #>   H1   H2   H3   H4   H5  #> 0.01 0.02 0.04 0.04 0.70  #>  #> Adjusted p-values: #>   H1   H2   H3   H4   H5  #> 0.05 0.08 0.12 0.12 0.70  #>  #> Alpha: 0.05  #>  #> Hypothesis rejected: #>    H1    H2    H3    H4    H5  #>  TRUE FALSE FALSE FALSE FALSE  #>  #> Final graph after1steps: #> A graphMCP graph #> H1 (rejected, weight=0) #> H2 (weight=0.25) #> H3 (weight=0.25) #> H4 (weight=0.25) #> H5 (weight=0.25) #> Edges: #> H2  -( 0.333333333333333 )->  H3  #> H2  -( 0.333333333333333 )->  H4  #> H2  -( 0.333333333333333 )->  H5  #> H3  -( 0.333333333333333 )->  H2  #> H3  -( 0.333333333333333 )->  H4  #> H3  -( 0.333333333333333 )->  H5  #> H4  -( 0.333333333333333 )->  H2  #> H4  -( 0.333333333333333 )->  H3  #> H4  -( 0.333333333333333 )->  H5  #> H5  -( 0.333333333333333 )->  H2  #> H5  -( 0.333333333333333 )->  H3  #> H5  -( 0.333333333333333 )->  H4  #>  # Simple Bonferroni with empty graph: g2 <- matrix2graph(matrix(0, nrow=5, ncol=5)) gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7)) #> gMCP-Result #>  #> Initial graph: #> A graphMCP graph #> H1 (weight=0.2) #> H2 (weight=0.2) #> H3 (weight=0.2) #> H4 (weight=0.2) #> H5 (weight=0.2) #> No edges. #>  #>  #> P-values: #>   H1   H2   H3   H4   H5  #> 0.01 0.02 0.04 0.04 0.70  #>  #> Adjusted p-values: #>   H1   H2   H3   H4   H5  #> 0.05 0.10 0.20 0.20 1.00  #>  #> Alpha: 0.05  #>  #> Hypothesis rejected: #>    H1    H2    H3    H4    H5  #>  TRUE FALSE FALSE FALSE FALSE  #>  #> Final graph after1steps: #> A graphMCP graph #> Sum of weight: 0.8 #> H1 (rejected, weight=0) #> H2 (weight=0.2) #> H3 (weight=0.2) #> H4 (weight=0.2) #> H5 (weight=0.2) #> No edges. #>  # With 'upscale=TRUE' equal to BonferroniHolm: gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7), upscale=TRUE) #> gMCP-Result #>  #> Initial graph: #> A graphMCP graph #> H1 (weight=0.2) #> H2 (weight=0.2) #> H3 (weight=0.2) #> H4 (weight=0.2) #> H5 (weight=0.2) #> No edges. #>  #>  #> P-values: #>   H1   H2   H3   H4   H5  #> 0.01 0.02 0.04 0.04 0.70  #>  #> Adjusted p-values: #>   H1   H2   H3   H4   H5  #> 0.05 0.08 0.12 0.12 0.70  #>  #> Alpha: 0.05  #>  #> Hypothesis rejected: #>    H1    H2    H3    H4    H5  #>  TRUE FALSE FALSE FALSE FALSE  #>  #> Final graph after1steps: #> A graphMCP graph #> H1 (rejected, weight=0) #> H2 (weight=0.25) #> H3 (weight=0.25) #> H4 (weight=0.25) #> H5 (weight=0.25) #> No edges. #>"},{"path":"https://merck.github.io/gMCPLite/reference/gMCPLite-package.html","id":null,"dir":"Reference","previous_headings":"","what":"gMCPLite: Lightweight Graph Based Multiple Comparison Procedures — gMCPLite-package","title":"gMCPLite: Lightweight Graph Based Multiple Comparison Procedures — gMCPLite-package","text":"lightweight fork 'gMCP' functions graphical described multiple test procedures introduced Bretz et al. (2009) doi:10.1002/sim.3495  Bretz et al. (2011) doi:10.1002/bimj.201000239 . Implements flexible function using 'ggplot2' create multiplicity graph visualizations. Contains instructions multiplicity graph graphical testing group sequential design, described Maurer Bretz (2013) doi:10.1080/19466315.2013.807748 , necessary unit testing using 'testthat'.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/gMCPLite-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"gMCPLite: Lightweight Graph Based Multiple Comparison Procedures — gMCPLite-package","text":"Maintainer: Yalin Zhu yalin.zhu@merck.com (ORCID) Authors: Yilong Zhang elong0527@gmail.com Xuan Deng xuan.deng@merck.com Keaven Anderson keaven_anderson@merck.com Nan Xiao nan.xiao1@merck.com (ORCID) contributors: Kornelius Rohmeyer rohmeyer@small-projects.de (gMCP author) [contributor] Florian Klinglmueller float@lefant.net (gMCP author) [contributor] gMCP project contributors (gMCP package) [copyright holder] Merck & Co., Inc., Rahway, NJ, USA affiliates [copyright holder]","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCPResult-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class gMCPResult — gMCPResult-class","title":"Class gMCPResult — gMCPResult-class","text":"gMCPResult object describes evaluated sequentially rejective multiple test procedure.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gMCPResult-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class gMCPResult — gMCPResult-class","text":"graphs Object class list. alpha numeric specifying maximal type error rate. pvalues numeric vector p-values. rejected logical vector rejected null hypotheses. adjPValues numeric vector adjusted p-values.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/gMCPResult-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class gMCPResult — gMCPResult-class","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gPADInterim-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class gPADInterim — gPADInterim-class","title":"Class gPADInterim — gPADInterim-class","text":"gPADInterim object describes object holding interim information adaptive procedure based preplanned graphical procedure.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/gPADInterim-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class gPADInterim — gPADInterim-class","text":"Aj Object class numeric. Giving partial     conditional errors (PCEs) elementary hypotheses     intersection hypothesis BJ numeric specifying sum PCEs per     intersection hypothesis. z1 numeric vector first stage     z-scores. v numeric specifying proportion     measurements collected interim preplanned Object class graphMCP     specifying preplanned graphical procedure. alpha numeric giving alpha level     pre-planned test","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/gPADInterim-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class gPADInterim — gPADInterim-class","text":"Florian Klinglmueller float@lefant.net","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generatePvals.html","id":null,"dir":"Reference","previous_headings":"","what":"generatePvals — generatePvals","title":"generatePvals — generatePvals","text":"compute adjusted p-values either closed test defined graph elementary hypotheses within intersection hypotheses","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generatePvals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generatePvals — generatePvals","text":"","code":"generatePvals(   g,   w,   cr,   p,   adjusted = TRUE,   hint = generateWeights(g, w),   upscale = FALSE )"},{"path":"https://merck.github.io/gMCPLite/reference/generatePvals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generatePvals — generatePvals","text":"g graph defined matrix, element defines much local alpha reserved hypothesis corresponding row index passed hypothesis corresponding column index w vector weights, defines much overall alpha initially reserved elementary hypothesis cr correlation matrix p-values arise one-sided tests multivariate normal distributed test statistics correlation partially known. Unknown values can set NA. (See details information) p vector observed unadjusted p-values, belong test-statistics joint multivariate normal null distribution (partially) known correlation matrix cr adjusted logical, TRUE (default) adjusted p-values closed test returned, else matrix p-values adjusted intersection hypothesis returned hint intersection hypotheses weights already computed (output generateWeights) can passed otherwise computed execution upscale FALSE (default) p-values additionally adjusted case non-exhaustive weights specified. (See details)","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generatePvals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generatePvals — generatePvals","text":"adjusted set true returns vector adjusted p-values. elementary null hypothesis rejected corresponding adjusted p-value predetermined alpha level. adjusted set false matrix p-values adjusted within intersection hypotheses returned.  intersection corresponding line given conversion line number binary (eg. 13 binary 1101 corresponds (H1,H2,H4)). adjusted p-value within given line falls alpha, corresponding intersection hypotheses can rejected.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generatePvals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"generatePvals — generatePvals","text":"assumed global null hypothesis \\((\\Phi^{-1}(1-p_1),...,\\Phi^{-1}(1-p_m))\\) follow multivariate normal distribution correlation matrix cr \\(\\Phi^{-1}\\) denotes inverse standard normal distribution function. example, case \\(p_1,..., p_m\\) raw p-values one-sided z-tests elementary hypotheses correlation z-test statistics generated overlap observations (e.g. comparison common control, group-sequential analyses etc.). application transformation \\(\\Phi^{-1}(1-p_i)\\) raw p-values two-sided test general lead multivariate normal distribution. Partial knowledge correlation matrix supported. correlation matrix passed numeric matrix elements form: \\(cr[,] = 1\\) diagonal elements, \\(cr[,j] = \\rho_{ij}\\), \\(\\rho_{ij}\\) known value correlation \\(\\Phi^{-1}(1-p_i)\\) \\(\\Phi^{-1}(1-p_j)\\) NA corresponding correlation unknown. example cr[1,2]=0 indicates first second test statistic uncorrelated, whereas cr[2,3] = NA means true correlation statistics two three unknown may take values -1 1. correlation specified complete blocks (ie.: cor(,j), cor(,k) !=j!=k specified cor(j,k) specified well) otherwise corresponding intersection null hypotheses tests uniquely defined error returned. parametric tests (Bretz et al. (2011)) defined tests intersection null hypotheses always exhaust full alpha level even sum weights strictly smaller one. consequence certain test procedures test intersection null hypothesis full level alpha may implemented (e.g., single step Dunnett test). upscale set FALSE (default) parametric tests performed reduced level alpha sum(w) * alpha p-values adjusted accordingly test procedures non-exhaustive weighting strategies may implemented. set TRUE tests performed defined Equation (3) (Bretz et al. (2011)).","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generatePvals.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"generatePvals — generatePvals","text":"Bretz F, Maurer W, Brannath W, Posch M; (2008) - graphical approach sequentially rejective multiple testing procedures. - Stat Med - 28/4, 586-604 Bretz F, Posch M, Glimm E, Klinglmueller F, Maurer W, Rohmeyer K; (2011) - Graphical approaches multiple endpoint problems using weighted Bonferroni, Simes parametric tests - appear","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generatePvals.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"generatePvals — generatePvals","text":"Florian Klinglmueller","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generatePvals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"generatePvals — generatePvals","text":"","code":"## Define some graph as matrix g <- matrix(c(0,0,1,0, 0,0,0,1, 0,1,0,0, 1,0,0,0), nrow = 4, byrow=TRUE) ## Choose weights w <- c(.5,.5,0,0) ## Some correlation (upper and lower first diagonal 1/2) c <- diag(4) c[1:2,3:4] <- NA c[3:4,1:2] <- NA c[1,2] <- 1/2 c[2,1] <- 1/2 c[3,4] <- 1/2 c[4,3] <- 1/2 ## p-values as Section 3 of Bretz et al. (2011), p <- c(0.0121,0.0337,0.0084,0.0160)  ## Boundaries for correlated test statistics at alpha level .05: generatePvals(g,w,c,p) #> [1] 0.0242 0.0337 0.0242 0.0337  g <- Entangled2Maurer2012() generatePvals(g=g, cr=diag(5), p=rep(0.1,5)) #> [1] 0.19 0.19 0.19 0.19 0.19"},{"path":"https://merck.github.io/gMCPLite/reference/generateWeights.html","id":null,"dir":"Reference","previous_headings":"","what":"generateWeights — generateWeights","title":"generateWeights — generateWeights","text":"compute Weights intersection Hypotheses closure graph based multiple testing procedure","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generateWeights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generateWeights — generateWeights","text":"","code":"generateWeights(g, w)"},{"path":"https://merck.github.io/gMCPLite/reference/generateWeights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generateWeights — generateWeights","text":"g Graph either defined matrix (element defines much local alpha reserved hypothesis corresponding row index passed hypothesis corresponding column index), graphMCP object entangledMCP object. w Vector weights, defines much overall alpha initially reserved elementary hypthosis. Can missing g graphMCP object (case weights graph object used). ignored g entangledMCP object (since matrix weights object used).","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generateWeights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generateWeights — generateWeights","text":"Returns matrix row corresponding one intersection hypothesis closure multiple testing problem. first half elements indicate whether elementary hypotheses intersection (1) (0). second half row gives weights allocated elementary hypotheses intersection.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generateWeights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"generateWeights — generateWeights","text":"Bretz F, Maurer W, Brannath W, Posch M; (2008) - graphical approach sequentially rejective multiple testing procedures. - Stat Med - 28/4, 586-604 Bretz F, Posch M, Glimm E, Klinglmueller F, Maurer W, Rohmeyer K; (2011) - Graphical approaches multiple endpoint problems using weighted Bonferroni, Simes parametric tests - appear","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generateWeights.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"generateWeights — generateWeights","text":"Florian Klinglmueller <float@lefant.net>, Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/generateWeights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"generateWeights — generateWeights","text":"","code":"g <- matrix(c(0,0,1,0,                0,0,0,1,                0,1,0,0,                1,0,0,0), nrow = 4,byrow=TRUE)  ## Choose weights  w <- c(.5,.5,0,0)  ## Weights of conventional gMCP test:  generateWeights(g,w) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #>  [1,]    0    0    0    1  0.0  0.0  0.0  1.0 #>  [2,]    0    0    1    0  0.0  0.0  1.0  0.0 #>  [3,]    0    0    1    1  0.0  0.0  0.5  0.5 #>  [4,]    0    1    0    0  0.0  1.0  0.0  0.0 #>  [5,]    0    1    0    1  0.0  1.0  0.0  0.0 #>  [6,]    0    1    1    0  0.0  0.5  0.5  0.0 #>  [7,]    0    1    1    1  0.0  0.5  0.5  0.0 #>  [8,]    1    0    0    0  1.0  0.0  0.0  0.0 #>  [9,]    1    0    0    1  0.5  0.0  0.0  0.5 #> [10,]    1    0    1    0  1.0  0.0  0.0  0.0 #> [11,]    1    0    1    1  0.5  0.0  0.0  0.5 #> [12,]    1    1    0    0  0.5  0.5  0.0  0.0 #> [13,]    1    1    0    1  0.5  0.5  0.0  0.0 #> [14,]    1    1    1    0  0.5  0.5  0.0  0.0 #> [15,]    1    1    1    1  0.5  0.5  0.0  0.0  g <- Entangled2Maurer2012() generateWeights(g) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    0    0    0    0    1  0.0  0.0  0.0  0.0   1.0 #>  [2,]    0    0    0    1    0  0.0  0.0  0.0  1.0   0.0 #>  [3,]    0    0    0    1    1  0.0  0.0  0.0  0.5   0.5 #>  [4,]    0    0    1    0    0  0.0  0.0  1.0  0.0   0.0 #>  [5,]    0    0    1    0    1  0.0  0.0  1.0  0.0   0.0 #>  [6,]    0    0    1    1    0  0.0  0.0  1.0  0.0   0.0 #>  [7,]    0    0    1    1    1  0.0  0.0  1.0  0.0   0.0 #>  [8,]    0    1    0    0    0  0.0  1.0  0.0  0.0   0.0 #>  [9,]    0    1    0    0    1  0.0  1.0  0.0  0.0   0.0 #> [10,]    0    1    0    1    0  0.0  0.5  0.0  0.5   0.0 #> [11,]    0    1    0    1    1  0.0  0.5  0.0  0.5   0.0 #> [12,]    0    1    1    0    0  0.0  0.5  0.5  0.0   0.0 #> [13,]    0    1    1    0    1  0.0  0.5  0.5  0.0   0.0 #> [14,]    0    1    1    1    0  0.0  0.5  0.5  0.0   0.0 #> [15,]    0    1    1    1    1  0.0  0.5  0.5  0.0   0.0 #> [16,]    1    0    0    0    0  1.0  0.0  0.0  0.0   0.0 #> [17,]    1    0    0    0    1  0.5  0.0  0.0  0.0   0.5 #> [18,]    1    0    0    1    0  1.0  0.0  0.0  0.0   0.0 #> [19,]    1    0    0    1    1  0.5  0.0  0.0  0.0   0.5 #> [20,]    1    0    1    0    0  0.5  0.0  0.5  0.0   0.0 #> [21,]    1    0    1    0    1  0.5  0.0  0.5  0.0   0.0 #> [22,]    1    0    1    1    0  0.5  0.0  0.5  0.0   0.0 #> [23,]    1    0    1    1    1  0.5  0.0  0.5  0.0   0.0 #> [24,]    1    1    0    0    0  0.5  0.5  0.0  0.0   0.0 #> [25,]    1    1    0    0    1  0.5  0.5  0.0  0.0   0.0 #> [26,]    1    1    0    1    0  0.5  0.5  0.0  0.0   0.0 #> [27,]    1    1    0    1    1  0.5  0.5  0.0  0.0   0.0 #> [28,]    1    1    1    0    0  0.5  0.5  0.0  0.0   0.0 #> [29,]    1    1    1    0    1  0.5  0.5  0.0  0.0   0.0 #> [30,]    1    1    1    1    0  0.5  0.5  0.0  0.0   0.0 #> [31,]    1    1    1    1    1  0.5  0.5  0.0  0.0   0.0"},{"path":"https://merck.github.io/gMCPLite/reference/graphMCP-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class graphMCP — graphMCP-class","title":"Class graphMCP — graphMCP-class","text":"graphMCP object describes sequentially rejective multiple test procedure.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/graphMCP-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class graphMCP — graphMCP-class","text":"m transition matrix. Can either numerical   character depending whether matrix contains variables .   Row column names names nodes. weights numeric. edgeAttr list edge attributes. nodeAttr list node attributes.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/graphMCP-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class graphMCP — graphMCP-class","text":"getMatrix signature(object = \"graphMCP\"): method getting transition matrix graph. getWeights signature(object = \"graphMCP\"): method getting weights.     third optional argument node specified, nodes weight returned. setWeights signature(object = \"graphMCP\"): method setting weights.     third optional argument node specified, nodes weight set. getRejected signature(object = \"graphMCP\"):       method getting information whether hypotheses marked graph already rejected.     second optional argument node specified, nodes boolean vector returned. getXCoordinates signature(object = \"graphMCP\"):       method getting x coordinates graph.     second optional argument node specified, nodes x coordinates returned.     x coordinates set yet NULL returned. getYCoordinates signature(object = \"graphMCP\"):       method getting y coordinates graph     second optional argument node specified, nodes x coordinates returned.     y coordinates set yet NULL returned. setEdge signature(=\"character\", =\"character\", graph=\"graphNEL\", weights=\"numeric\"):       method adding new edges given weights. setEdge signature(=\"character\", =\"character\", graph=\"graphMCP\", weights=\"character\"):       method adding new edges given weights.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/graphMCP-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class graphMCP — graphMCP-class","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/graphMCP-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class graphMCP — graphMCP-class","text":"","code":"m <- rbind(H11=c(0,   0.5, 0,   0.5, 0,   0  ),       H21=c(1/3, 0,   1/3, 0,   1/3, 0  ),       H31=c(0,   0.5, 0,   0,   0,   0.5),       H12=c(0,   1,   0,   0,   0,   0  ),       H22=c(0.5, 0,   0.5, 0,   0,   0  ),       H32=c(0,   1,   0,   0,   0,   0  ))  weights <- c(1/3, 1/3, 1/3, 0, 0, 0)  # Graph creation graph <- new(\"graphMCP\", m=m, weights=weights)  # Visualization settings nodeX <- rep(c(100, 300, 500), 2) nodeY <- rep(c(100, 300), each=3) graph@nodeAttr$X <- nodeX graph@nodeAttr$Y <- nodeY  getWeights(graph) #>       H11       H21       H31       H12       H22       H32  #> 0.3333333 0.3333333 0.3333333 0.0000000 0.0000000 0.0000000   getRejected(graph) #>   H11   H21   H31   H12   H22   H32  #> FALSE FALSE FALSE FALSE FALSE FALSE   pvalues <- c(0.1, 0.008, 0.005, 0.15, 0.04, 0.006) result <- gMCP(graph, pvalues)  getWeights(result@graphs[[4]]) #>       H11       H21       H31       H12       H22       H32  #> 0.6666667 0.0000000 0.0000000 0.0000000 0.3333333 0.0000000  getRejected(result@graphs[[4]]) #>   H11   H21   H31   H12   H22   H32  #> FALSE  TRUE  TRUE FALSE FALSE  TRUE"},{"path":"https://merck.github.io/gMCPLite/reference/graphTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiple testing using graphs — graphTest","title":"Multiple testing using graphs — graphTest","text":"Implements graphical test procedure described Bretz et al. (2009). Note gMCP function gMCP package performs task.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/graphTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiple testing using graphs — graphTest","text":"","code":"graphTest(   pvalues,   weights = NULL,   alpha = 0.05,   G = NULL,   cr = NULL,   graph = NULL,   verbose = FALSE,   test,   upscale = FALSE )"},{"path":"https://merck.github.io/gMCPLite/reference/graphTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiple testing using graphs — graphTest","text":"pvalues Either vector matrix containing local p-values hypotheses rows. weights Initial weight levels test procedure, case multiple graphs needs matrix. alpha Overall alpha level procedure. entangled graphs alpha numeric vector length equal number graphs, element specifying partial alpha respective graph. overall alpha level equals sum(alpha). G simple graphs G numeric matrix determining graph underlying test procedure. Note diagonal need contain 0s, rows need sum 1.  entangled graphs needs list containing different graph matrices elements. cr Correlation matrix used parametric test. cr==NULL Bonferroni based test procedure used. graph alternative specification via weights G one can also hand graphMCP object code. graphMCP objects can created example graphGUI function. verbose verbose TRUE, additional information graphical rejection procedure displayed. test parametric case one way handle subgraphs less full alpha. parameter test missing, tests performed described Bretz et al. (2011), .e. tests intersection null hypotheses always exhaust full alpha level even sum weights strictly smaller one. test=\"simple-parametric\" tests performed defined Equation (3) Bretz et al. (2011). upscale Logical. upscale=FALSE intersection hypotheses (.e. subgraph) weighted test performed possibly reduced level alpha sum(w)*alpha, sum(w) sum node weights subset. upscale=TRUE weights upscaled, sum(w)=1.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/graphTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiple testing using graphs — graphTest","text":"vector matrix containing test results hypotheses consideration. Significant tests denoted 1, non-significant results 0.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/graphTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multiple testing using graphs — graphTest","text":"Bretz, F., Maurer, W., Brannath, W. Posch, M. (2009) graphical approach sequentially rejective multiple test procedures. Statistics Medicine, 28, 586--604 Bretz, F., Maurer, W. Hommel, G. (2010) Test power considerations multiple endpoint analyses using sequentially rejective graphical procedures, appear Statistics Medicine","code":""},{"path":"https://merck.github.io/gMCPLite/reference/graphTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiple testing using graphs — graphTest","text":"","code":"#### example from Bretz et al. (2010) weights <- c(1/3, 1/3, 1/3, 0, 0, 0) graph <- rbind(c(0,       0.5, 0,     0.5, 0,      0),                c(1/3,     0,   1/3,    0,   1/3,    0),                c(0,       0.5, 0,     0,   0,      0.5),                c(0,       1,   0,     0,   0,      0),                c(0.5,     0,   0.5,   0,   0,      0),                c(0,       1,   0,     0,   0,      0)) pvals <- c(0.1, 0.008, 0.005, 0.15, 0.04, 0.006) graphTest(pvals, weights, alpha=0.025, graph) #> H1 H2 H3 H4 H5 H6  #>  0  1  1  0  0  1  #> attr(,\"last.alphas\") #> [1] 0.016666667 0.000000000 0.000000000 0.000000000 0.008333333 #> [6] 0.000000000 #> attr(,\"last.G\") #>      [,1] [,2] [,3]      [,4]      [,5] [,6] #> [1,]  0.0    0    0 0.6666667 0.3333333    0 #> [2,]  0.0    0    0 0.0000000 0.0000000    0 #> [3,]  0.0    0    0 0.0000000 0.0000000    0 #> [4,]  0.5    0    0 0.0000000 0.5000000    0 #> [5,]  1.0    0    0 0.0000000 0.0000000    0 #> [6,]  0.0    0    0 0.0000000 0.0000000    0  ## observe graphical procedure in detail graphTest(pvals, weights, alpha=0.025, graph, verbose = TRUE) #> ------------------------------------------------------------------ #> Reject hypothesis 2 #> Updated alphas and graph: #>  #> a1: 0.011 a2: 0.000 a3: 0.011 a4: 0.000 a5: 0.003 a6: 0.000  #>  #> G11: 0.000 G12: 0.000 G13: 0.200 G14: 0.600 G15: 0.200 G16: 0.000  #> G21: 0.000 G22: 0.000 G23: 0.000 G24: 0.000 G25: 0.000 G26: 0.000  #> G31: 0.200 G32: 0.000 G33: 0.000 G34: 0.000 G35: 0.200 G36: 0.600  #> G41: 0.333 G42: 0.000 G43: 0.333 G44: 0.000 G45: 0.333 G46: 0.000  #> G51: 0.500 G52: 0.000 G53: 0.500 G54: 0.000 G55: 0.000 G56: 0.000  #> G61: 0.333 G62: 0.000 G63: 0.333 G64: 0.000 G65: 0.333 G66: 0.000  #>  #> ------------------------------------------------------------------ #> Reject hypothesis 3 #> Updated alphas and graph: #>  #> a1: 0.013 a2: 0.000 a3: 0.000 a4: 0.000 a5: 0.005 a6: 0.007  #>  #> G11: 0.000 G12: 0.000 G13: 0.000 G14: 0.625 G15: 0.250 G16: 0.125  #> G21: 0.000 G22: 0.000 G23: 0.000 G24: 0.000 G25: 0.000 G26: 0.000  #> G31: 0.000 G32: 0.000 G33: 0.000 G34: 0.000 G35: 0.000 G36: 0.000  #> G41: 0.400 G42: 0.000 G43: 0.000 G44: 0.000 G45: 0.400 G46: 0.200  #> G51: 0.667 G52: 0.000 G53: 0.000 G54: 0.000 G55: 0.000 G56: 0.333  #> G61: 0.500 G62: 0.000 G63: 0.000 G64: 0.000 G65: 0.500 G66: 0.000  #>  #> ------------------------------------------------------------------ #> Reject hypothesis 6 #> Updated alphas and graph: #>  #> a1: 0.017 a2: 0.000 a3: 0.000 a4: 0.000 a5: 0.008 a6: 0.000  #>  #> G11: 0.000 G12: 0.000 G13: 0.000 G14: 0.667 G15: 0.333 G16: 0.000  #> G21: 0.000 G22: 0.000 G23: 0.000 G24: 0.000 G25: 0.000 G26: 0.000  #> G31: 0.000 G32: 0.000 G33: 0.000 G34: 0.000 G35: 0.000 G36: 0.000  #> G41: 0.500 G42: 0.000 G43: 0.000 G44: 0.000 G45: 0.500 G46: 0.000  #> G51: 1.000 G52: 0.000 G53: 0.000 G54: 0.000 G55: 0.000 G56: 0.000  #> G61: 0.000 G62: 0.000 G63: 0.000 G64: 0.000 G65: 0.000 G66: 0.000  #>  #> H1 H2 H3 H4 H5 H6  #>  0  1  1  0  0  1  #> attr(,\"last.alphas\") #> [1] 0.016666667 0.000000000 0.000000000 0.000000000 0.008333333 #> [6] 0.000000000 #> attr(,\"last.G\") #>      [,1] [,2] [,3]      [,4]      [,5] [,6] #> [1,]  0.0    0    0 0.6666667 0.3333333    0 #> [2,]  0.0    0    0 0.0000000 0.0000000    0 #> [3,]  0.0    0    0 0.0000000 0.0000000    0 #> [4,]  0.5    0    0 0.0000000 0.5000000    0 #> [5,]  1.0    0    0 0.0000000 0.0000000    0 #> [6,]  0.0    0    0 0.0000000 0.0000000    0  ## now use many p-values (useful for power simulations) pvals <- matrix(rbeta(6e4, 1, 30), ncol = 6) out <- graphTest(pvals, weights, alpha=0.025, graph) head(out) #>      H1 H2 H3 H4 H5 H6 #> [1,]  0  1  0  0  0  0 #> [2,]  0  1  0  0  0  0 #> [3,]  0  0  1  0  0  0 #> [4,]  0  1  1  0  0  0 #> [5,]  1  0  1  0  0  1 #> [6,]  0  0  0  0  0  0 # example using multiple graphs (instead of 1) G1 <- rbind(c(0,0.5,0.5,0,0), c(0,0,1,0,0),             c(0, 0, 0, 1-0.01, 0.01), c(0, 1, 0, 0, 0),             c(0, 0, 0, 0, 0)) G2 <- rbind(c(0,0,1,0,0), c(0.5,0,0.5,0,0),             c(0, 0, 0, 0.01, 1-0.01), c(0, 0, 0, 0, 0),             c(1, 0, 0, 0, 0)) weights <- rbind(c(1, 0, 0, 0, 0), c(0, 1, 0, 0, 0)) pvals <- c(0.012, 0.025, 0.005, 0.0015, 0.0045) out <- graphTest(pvals, weights, alpha=c(0.0125, 0.0125), G=list(G1, G2), verbose = TRUE) #> ------------------------------------------------------------------ #> Reject hypothesis 1 #> Updated alphas and graphs: #>  #> a11: 0.000 a12: 0.006 a13: 0.006 a14: 0.000 a15: 0.000  #>  #> G1,11: 0.000 G1,12: 0.000 G1,13: 0.000 G1,14: 0.000 G1,15: 0.000  #> G1,21: 0.000 G1,22: 0.000 G1,23: 1.000 G1,24: 0.000 G1,25: 0.000  #> G1,31: 0.000 G1,32: 0.000 G1,33: 0.000 G1,34: 0.990 G1,35: 0.010  #> G1,41: 0.000 G1,42: 1.000 G1,43: 0.000 G1,44: 0.000 G1,45: 0.000  #> G1,51: 0.000 G1,52: 0.000 G1,53: 0.000 G1,54: 0.000 G1,55: 0.000  #>  #> a21: 0.000 a22: 0.013 a23: 0.000 a24: 0.000 a25: 0.000  #>  #> G2,11: 0.000 G2,12: 0.000 G2,13: 0.000 G2,14: 0.000 G2,15: 0.000  #> G2,21: 0.000 G2,22: 0.000 G2,23: 1.000 G2,24: 0.000 G2,25: 0.000  #> G2,31: 0.000 G2,32: 0.000 G2,33: 0.000 G2,34: 0.010 G2,35: 0.990  #> G2,41: 0.000 G2,42: 0.000 G2,43: 0.000 G2,44: 0.000 G2,45: 0.000  #> G2,51: 0.000 G2,52: 0.000 G2,53: 1.000 G2,54: 0.000 G2,55: 0.000  #>  #> ------------------------------------------------------------------ #> Reject hypothesis 3 #> Updated alphas and graphs: #>  #> a11: 0.000 a12: 0.006 a13: 0.000 a14: 0.006 a15: 0.000  #>  #> G1,11: 0.000 G1,12: 0.000 G1,13: 0.000 G1,14: 0.000 G1,15: 0.000  #> G1,21: 0.000 G1,22: 0.000 G1,23: 0.000 G1,24: 0.990 G1,25: 0.010  #> G1,31: 0.000 G1,32: 0.000 G1,33: 0.000 G1,34: 0.000 G1,35: 0.000  #> G1,41: 0.000 G1,42: 1.000 G1,43: 0.000 G1,44: 0.000 G1,45: 0.000  #> G1,51: 0.000 G1,52: 0.000 G1,53: 0.000 G1,54: 0.000 G1,55: 0.000  #>  #> a21: 0.000 a22: 0.013 a23: 0.000 a24: 0.000 a25: 0.000  #>  #> G2,11: 0.000 G2,12: 0.000 G2,13: 0.000 G2,14: 0.000 G2,15: 0.000  #> G2,21: 0.000 G2,22: 0.000 G2,23: 0.000 G2,24: 0.010 G2,25: 0.990  #> G2,31: 0.000 G2,32: 0.000 G2,33: 0.000 G2,34: 0.000 G2,35: 0.000  #> G2,41: 0.000 G2,42: 0.000 G2,43: 0.000 G2,44: 0.000 G2,45: 0.000  #> G2,51: 0.000 G2,52: 0.000 G2,53: 0.000 G2,54: 1.000 G2,55: 0.000  #>  #> ------------------------------------------------------------------ #> Reject hypothesis 4 #> Updated alphas and graphs: #>  #> a11: 0.000 a12: 0.012 a13: 0.000 a14: 0.000 a15: 0.000  #>  #> G1,11: 0.000 G1,12: 0.000 G1,13: 0.000 G1,14: 0.000 G1,15: 0.000  #> G1,21: 0.000 G1,22: 0.000 G1,23: 0.000 G1,24: 0.000 G1,25: 1.000  #> G1,31: 0.000 G1,32: 0.000 G1,33: 0.000 G1,34: 0.000 G1,35: 0.000  #> G1,41: 0.000 G1,42: 0.000 G1,43: 0.000 G1,44: 0.000 G1,45: 0.000  #> G1,51: 0.000 G1,52: 0.000 G1,53: 0.000 G1,54: 0.000 G1,55: 0.000  #>  #> a21: 0.000 a22: 0.013 a23: 0.000 a24: 0.000 a25: 0.000  #>  #> G2,11: 0.000 G2,12: 0.000 G2,13: 0.000 G2,14: 0.000 G2,15: 0.000  #> G2,21: 0.000 G2,22: 0.000 G2,23: 0.000 G2,24: 0.000 G2,25: 0.990  #> G2,31: 0.000 G2,32: 0.000 G2,33: 0.000 G2,34: 0.000 G2,35: 0.000  #> G2,41: 0.000 G2,42: 0.000 G2,43: 0.000 G2,44: 0.000 G2,45: 0.000  #> G2,51: 0.000 G2,52: 0.000 G2,53: 0.000 G2,54: 0.000 G2,55: 0.000  #>   ## now again with many p-values pvals <- matrix(rbeta(5e4, 1, 30), ncol = 5) out <- graphTest(pvals, weights, alpha=c(0.0125, 0.0125), G=list(G1, G2)) head(out) #>      H1 H2 H3 H4 H5 #> [1,]  1  0  0  0  0 #> [2,]  1  0  0  0  0 #> [3,]  1  0  0  0  0 #> [4,]  0  1  0  0  0 #> [5,]  0  0  0  0  0 #> [6,]  0  0  0  0  0"},{"path":"https://merck.github.io/gMCPLite/reference/hGraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Create multiplicity graphs using ggplot2 — hGraph","title":"Create multiplicity graphs using ggplot2 — hGraph","text":"Plots multiplicity graph defined user inputs. graph can also used ***gMCP*** package evaluate set nominal p-values tests hypotheses graph.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/hGraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create multiplicity graphs using ggplot2 — hGraph","text":"","code":"hGraph(   nHypotheses = 4,   nameHypotheses = paste(\"H\", (1:nHypotheses), sep = \"\"),   alphaHypotheses = 0.025/nHypotheses,   m = matrix(array(1/(nHypotheses - 1), nHypotheses^2), nrow = nHypotheses) -     diag(1/(nHypotheses - 1), nHypotheses),   fill = 1,   palette = grDevices::gray.colors(length(unique(fill)), start = 0.5, end = 0.8),   labels = LETTERS[1:length(unique(fill))],   legend.name = \" \",   legend.position = \"none\",   halfWid = 0.5,   halfHgt = 0.5,   trhw = 0.1,   trhh = 0.075,   trprop = 1/3,   digits = 5,   trdigits = 2,   size = 6,   boxtextsize = 4,   legend.textsize = size * 2.5,   arrowsize = 0.02,   radianStart = if ((nHypotheses)%%2 != 0) {      pi * (1/2 + 1/nHypotheses)  } else     {      pi * (1 + 2/nHypotheses)/2  },   offset = pi/4/nHypotheses,   xradius = 2,   yradius = xradius,   x = NULL,   y = NULL,   wchar = \"\\u03b1\" )"},{"path":"https://merck.github.io/gMCPLite/reference/hGraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create multiplicity graphs using ggplot2 — hGraph","text":"nHypotheses number hypotheses graph nameHypotheses hypothesis names alphaHypotheses alpha-levels weights ellipses m square transition matrix dimension `nHypotheses` fill grouping variable hypotheses palette colors groups labels text labels groups legend.name text legend header legend.position text string x,y coordinates legend halfWid half width ellipses halfHgt half height ellipses trhw transition box width trhh transition box height trprop proportion transition arrow length transition box placed digits number digits show alphaHypotheses trdigits digits displayed transition weights size text size ellipses boxtextsize transition text size legend.textsize legend text size arrowsize size arrowhead transition arrows radianStart radians origin first ellipse; nodes spaced equally clockwise order centers ellipse default offset rotational offset radians transition weight arrows xradius horizontal ellipse diameter ellipses drawn yradius vertical ellipse diameter ellipses drawn x x coordinates hypothesis ellipses elliptical arrangement wanted y y coordinates hypothesis ellipses elliptical arrangement wanted wchar character alphaHypotheses ellipses; defaults Unicode escape sequence \\u03b1 (Greek letter alpha). See list Unicode characters comprehensive character list.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/hGraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create multiplicity graphs using ggplot2 — hGraph","text":"`ggplot` object multi-layer multiplicity graph","code":""},{"path":"https://merck.github.io/gMCPLite/reference/hGraph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create multiplicity graphs using ggplot2 — hGraph","text":"See vignette **Multiplicity graphs formatting using ggplot2** explanation formatting.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/hGraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create multiplicity graphs using ggplot2 — hGraph","text":"","code":"# Defaults: note clockwise ordering hGraph(5)  # Add colors (default is 3 gray shades) hGraph(3,fill=1:3)  # Colorblind palette cbPalette <- c(\"#999999\", \"#E69F00\", \"#56B4E9\", \"#009E73\",                \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\") hGraph(6,fill=as.factor(1:6),palette=cbPalette)  # Use a hue palette hGraph(4,fill=factor(1:4),palette=scales::hue_pal(l=75)(4))  # different alpha allocation, hypothesis names and transitions alphaHypotheses <- c(.005,.007,.013) nameHypotheses <- c(\"ORR\",\"PFS\",\"OS\") m <- matrix(c(0,1,0,               0,0,1,               1,0,0),nrow=3,byrow=TRUE) hGraph(3,alphaHypotheses=alphaHypotheses,nameHypotheses=nameHypotheses,m=m)  # Custom position and size of ellipses, change text to multi-line text # Adjust box width # add legend in middle of plot hGraph(3,x=sqrt(0:2),y=c(1,3,1.5),size=6,halfWid=.3,halfHgt=.3, trhw=0.6,        palette=cbPalette[2:4], fill = c(1, 2, 2),        legend.position = c(.6,.5), legend.name = \"Legend:\", labels = c(\"Group 1\", \"Group 2\"),        nameHypotheses=c(\"H1:\\n Long name\",\"H2:\\n Longer name\",\"H3:\\n Longest name\"))"},{"path":"https://merck.github.io/gMCPLite/reference/joinGraphs.html","id":null,"dir":"Reference","previous_headings":"","what":"Joins two graphMCP objects — joinGraphs","title":"Joins two graphMCP objects — joinGraphs","text":"Creates new graphMCP object joining two given graphMCP objects.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/joinGraphs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Joins two graphMCP objects — joinGraphs","text":"","code":"joinGraphs(graph1, graph2, xOffset = 0, yOffset = 200)"},{"path":"https://merck.github.io/gMCPLite/reference/joinGraphs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Joins two graphMCP objects — joinGraphs","text":"graph1 graph class graphMCP. graph2 graph class graphMCP. xOffset numeric specifying offset (x-axis) placing nodes edge labels second graph. yOffset numeric specifying offset (y-axis) placing nodes edge labels second graph.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/joinGraphs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Joins two graphMCP objects — joinGraphs","text":"graphMCP object represents graph consists two given graphs.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/joinGraphs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Joins two graphMCP objects — joinGraphs","text":"graph1 graph2 duplicates node names, nodes second graph renamed. sum weights graph1 graph2 exceeds 1, weights scaled sum equals 1. description attribute either graph discarded.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/joinGraphs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Joins two graphMCP objects — joinGraphs","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/joinGraphs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Joins two graphMCP objects — joinGraphs","text":"","code":"g1 <- BonferroniHolm(2) g2 <- BonferroniHolm(3)  suppressWarnings(joinGraphs(g1, g2)) #> A graphMCP graph #> H1 (weight=0.25) #> H2 (weight=0.25) #> H4 (weight=0.1667) #> H5 (weight=0.1667) #> H3 (weight=0.1667) #> Edges: #> H1  -( 1 )->  H2  #> H2  -( 1 )->  H1  #> H4  -( 0.5 )->  H5  #> H4  -( 0.5 )->  H3  #> H5  -( 0.5 )->  H4  #> H5  -( 0.5 )->  H3  #> H3  -( 0.5 )->  H4  #> H3  -( 0.5 )->  H5  #>"},{"path":"https://merck.github.io/gMCPLite/reference/matrix2graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix2Graph and Graph2Matrix — matrix2graph","title":"Matrix2Graph and Graph2Matrix — matrix2graph","text":"Creates graph class graphMCP given transition matrix vice versa.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/matrix2graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix2Graph and Graph2Matrix — matrix2graph","text":"","code":"matrix2graph(m, weights = rep(1/dim(m)[1], dim(m)[1]))  graph2matrix(graph)"},{"path":"https://merck.github.io/gMCPLite/reference/matrix2graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix2Graph and Graph2Matrix — matrix2graph","text":"m transition matrix. weights numeric initial weights. graph graph class graphMCP.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/matrix2graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix2Graph and Graph2Matrix — matrix2graph","text":"graph class graphMCP given transition matrix matrix2graph.  transition matrix graphMCP graph graph2matrix.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/matrix2graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matrix2Graph and Graph2Matrix — matrix2graph","text":"hypotheses names row names NULL, column names also NULL type H1, H2, H3, ... diagonal matrix unequal zero, values ignored warning given.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/matrix2graph.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Matrix2Graph and Graph2Matrix — matrix2graph","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/matrix2graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix2Graph and Graph2Matrix — matrix2graph","text":"","code":"# Bonferroni-Holm: m <- matrix(rep(1/3, 16), nrow=4) diag(m) <- c(0, 0, 0, 0) graph <- matrix2graph(m) print(graph) #> A graphMCP graph #> H1 (weight=0.25) #> H2 (weight=0.25) #> H3 (weight=0.25) #> H4 (weight=0.25) #> Edges: #> H1  -( 0.333333333333333 )->  H2  #> H1  -( 0.333333333333333 )->  H3  #> H1  -( 0.333333333333333 )->  H4  #> H2  -( 0.333333333333333 )->  H1  #> H2  -( 0.333333333333333 )->  H3  #> H2  -( 0.333333333333333 )->  H4  #> H3  -( 0.333333333333333 )->  H1  #> H3  -( 0.333333333333333 )->  H2  #> H3  -( 0.333333333333333 )->  H4  #> H4  -( 0.333333333333333 )->  H1  #> H4  -( 0.333333333333333 )->  H2  #> H4  -( 0.333333333333333 )->  H3  #>  graph2matrix(graph) #>           H1        H2        H3        H4 #> H1 0.0000000 0.3333333 0.3333333 0.3333333 #> H2 0.3333333 0.0000000 0.3333333 0.3333333 #> H3 0.3333333 0.3333333 0.0000000 0.3333333 #> H4 0.3333333 0.3333333 0.3333333 0.0000000"},{"path":"https://merck.github.io/gMCPLite/reference/parametric.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Weighted parametric test — parametric.test","title":"Weighted parametric test — parametric.test","text":"assumed global null hypothesis \\((\\Phi^{-1}(1-p_1),...,\\Phi^{-1}(1-p_m))\\) follow multivariate normal distribution correlation matrix correlation \\(\\Phi^{-1}\\) denotes inverse standard normal distribution function.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/parametric.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weighted parametric test — parametric.test","text":"","code":"parametric.test(   pvalues,   weights,   alpha = 0.05,   adjPValues = TRUE,   verbose = FALSE,   correlation,   ... )"},{"path":"https://merck.github.io/gMCPLite/reference/parametric.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weighted parametric test — parametric.test","text":"pvalues numeric vector specifying p-values. weights numeric vector weights. alpha numeric specifying maximal allowed type one error rate. adjPValues==TRUE (default) parameter alpha used. adjPValues Logical scalar. TRUE (default) adjusted p-value weighted parametric test returned. Otherwise adjPValues==FALSE logical value returned whether null hypothesis can rejected. verbose Logical scalar. TRUE verbose output generated. correlation Correlation matrix. parametric tests p-values must arise one-sided tests multivariate normal distributed test statistics correlation (partially) known. case weighted parametric closed test performed (also see generatePvals). Unknown values can set NA. (See details information) ... arguments possibly passed gMCP used test procedures one.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/parametric.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weighted parametric test — parametric.test","text":"adjusted p-value decision rejection","code":""},{"path":"https://merck.github.io/gMCPLite/reference/parametric.test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Weighted parametric test — parametric.test","text":"example, case \\(p_1,..., p_m\\) raw p-values one-sided z-tests elementary hypotheses correlation z-test statistics generated overlap observations (e.g. comparison common control, group-sequential analyses etc.). application transformation \\(\\Phi^{-1}(1-p_i)\\) raw p-values two-sided test general lead multivariate normal distribution. Partial knowledge correlation matrix supported. correlation matrix passed numeric matrix elements form: \\(correlation[,] = 1\\) diagonal elements, \\(correlation[,j] = \\rho_{ij}\\), \\(\\rho_{ij}\\) known value correlation \\(\\Phi^{-1}(1-p_i)\\) \\(\\Phi^{-1}(1-p_j)\\) NA corresponding correlation unknown. example correlation[1,2]=0 indicates first second test statistic uncorrelated, whereas correlation[2,3] = NA means true correlation statistics two three unknown may take values -1 1. correlation specified complete blocks (ie.: cor(,j), cor(,j') !=j!=j' specified cor(j,j') specified well) otherwise corresponding intersection null hypotheses tests uniquely defined error returned. details see given references.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/parametric.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Weighted parametric test — parametric.test","text":"Bretz F., Posch M., Glimm E., Klinglmueller F., Maurer W., Rohmeyer K. (2011): Graphical approaches multiple endpoint problems using weighted Bonferroni, Simes parametric tests. Biometrical Journal 53 (6), pages 894-913, Wiley.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/parametric.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weighted parametric test — parametric.test","text":"","code":"parametric.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), correlation = diag(3)) #> [1] 0.19 parametric.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), correlation = diag(3), adjPValues = FALSE) #> [1] FALSE"},{"path":"https://merck.github.io/gMCPLite/reference/permutations.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutation for a design matrix — permutations","title":"Permutation for a design matrix — permutations","text":"Permutation design matrix","code":""},{"path":"https://merck.github.io/gMCPLite/reference/permutations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutation for a design matrix — permutations","text":"","code":"permutations(n)"},{"path":"https://merck.github.io/gMCPLite/reference/permutations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutation for a design matrix — permutations","text":"n dimension matrix","code":""},{"path":"https://merck.github.io/gMCPLite/reference/permutations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutation for a design matrix — permutations","text":"n*(2^n) dimensional matrix","code":""},{"path":"https://merck.github.io/gMCPLite/reference/permutations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permutation for a design matrix — permutations","text":"","code":"permutations(3) #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    1 #> [3,]    0    1    0 #> [4,]    0    1    1 #> [5,]    1    0    0 #> [6,]    1    0    1 #> [7,]    1    1    0 #> [8,]    1    1    1"},{"path":"https://merck.github.io/gMCPLite/reference/placeNodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Placement of graph nodes — placeNodes","title":"Placement of graph nodes — placeNodes","text":"Places nodes graph according specified layout.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/placeNodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Placement of graph nodes — placeNodes","text":"","code":"placeNodes(graph, nrow, ncol, byrow = TRUE, topdown = TRUE, force = FALSE)"},{"path":"https://merck.github.io/gMCPLite/reference/placeNodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Placement of graph nodes — placeNodes","text":"graph graph class graphMCP class entangledMCP. nrow desired number rows. ncol desired number columns. byrow Logical whether graph filled rows (otherwise columns). topdown Logical whether rows filled top-bottom-. force Logical whether graph already layout given specified new layout.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/placeNodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Placement of graph nodes — placeNodes","text":"graph nodes placed according specified layout.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/placeNodes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Placement of graph nodes — placeNodes","text":"one nrow ncol given, attempt made infer number nodes graph parameter.  neither given, graph placed circle.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/placeNodes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Placement of graph nodes — placeNodes","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/placeNodes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Placement of graph nodes — placeNodes","text":"","code":"g <- matrix2graph(matrix(0, nrow=6, ncol=6))  g <- placeNodes(g, nrow=2, force=TRUE)"},{"path":"https://merck.github.io/gMCPLite/reference/rejectNode.html","id":null,"dir":"Reference","previous_headings":"","what":"Rejects a node/hypothesis and updates the graph accordingly. — rejectNode","title":"Rejects a node/hypothesis and updates the graph accordingly. — rejectNode","text":"Rejects node/hypothesis updates graph accordingly.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/rejectNode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rejects a node/hypothesis and updates the graph accordingly. — rejectNode","text":"","code":"rejectNode(graph, node, upscale = FALSE, verbose = FALSE, keepWeights = FALSE)"},{"path":"https://merck.github.io/gMCPLite/reference/rejectNode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rejects a node/hypothesis and updates the graph accordingly. — rejectNode","text":"graph graph class graphMCP entangledMCP. node character string specifying node reject. upscale Logical. upscale=TRUE weights non-rejected nodes scaled sum equal 1. forces keepWeights=FALSE reduce confusion, since otherwise sum weights become bigger 1. verbose Logical scalar.  TRUE verbose output generated sequentially rejection steps. keepWeights Logical scalar. FALSE weight node without outgoing edges set 0 removed.  Otherwise keeps weight.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/rejectNode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rejects a node/hypothesis and updates the graph accordingly. — rejectNode","text":"updated graph class graphMCP entangledMCP.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/rejectNode.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rejects a node/hypothesis and updates the graph accordingly. — rejectNode","text":"details see given references.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/rejectNode.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rejects a node/hypothesis and updates the graph accordingly. — rejectNode","text":"Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: graphical approach sequentially rejective multiple test procedures. Statistics Medicine 2009 vol. 28 issue 4 page 586-604. http://www.meduniwien.ac./fwf_adaptive/papers/bretz_2009_22.pdf","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/rejectNode.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Rejects a node/hypothesis and updates the graph accordingly. — rejectNode","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/rejectNode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rejects a node/hypothesis and updates the graph accordingly. — rejectNode","text":"","code":"m <- matrix(0, nrow = 4, ncol = 4) m[1,3] <- m[2,4] <- m[3,2] <- m[4,1] <- 1 p1 <- c(0.01, 0.005, 0.01, 0.5) a <- 0.05 w <- c(1/2, 1/2, 0, 0) g <- matrix2graph(m, w) gMCP(g, pvalues=p1, alpha=a) #> gMCP-Result #>  #> Initial graph: #> A graphMCP graph #> H1 (weight=0.5) #> H2 (weight=0.5) #> H3 (weight=0) #> H4 (weight=0) #> Edges: #> H1  -( 1 )->  H3  #> H2  -( 1 )->  H4  #> H3  -( 1 )->  H2  #> H4  -( 1 )->  H1  #>  #>  #> P-values: #>    H1    H2    H3    H4  #> 0.010 0.005 0.010 0.500  #>  #> Adjusted p-values: #>   H1   H2   H3   H4  #> 0.02 0.01 0.02 0.50  #>  #> Alpha: 0.05  #>  #> Hypothesis rejected: #>    H1    H2    H3    H4  #>  TRUE  TRUE  TRUE FALSE  #>  #> Final graph after3steps: #> A graphMCP graph #> H1 (rejected, weight=0) #> H2 (rejected, weight=0) #> H3 (rejected, weight=0) #> H4 (weight=1) #> No edges. #>  rejectNode(graph = g, node = 4) #> A graphMCP graph #> H1 (weight=0.5) #> H2 (weight=0.5) #> H3 (weight=0) #> H4 (rejected, weight=0) #> Edges: #> H1  -( 1 )->  H3  #> H2  -( 1 )->  H1  #> H3  -( 1 )->  H2  #>"},{"path":"https://merck.github.io/gMCPLite/reference/replaceVariables.html","id":null,"dir":"Reference","previous_headings":"","what":"Replaces variables in a general graph with specified numeric values — replaceVariables","title":"Replaces variables in a general graph with specified numeric values — replaceVariables","text":"Given list variables real values general graph processed variable replaced specified numeric value.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/replaceVariables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replaces variables in a general graph with specified numeric values — replaceVariables","text":"","code":"replaceVariables(   graph,   variables = list(),   ask = TRUE,   partial = FALSE,   expand = TRUE,   list = FALSE )"},{"path":"https://merck.github.io/gMCPLite/reference/replaceVariables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replaces variables in a general graph with specified numeric values — replaceVariables","text":"graph graph class graphMCP class entangledMCP. variables named list one specified real values, example list(=0.5, b=0.8, \"tau\"=0.5) list(=c(0.5, 0.8), b=0.8, \"tau\"=0.5). ask=TRUE list missing single variables missing list, user asked values (session interactive error thrown). interactively entered values single numbers supported. ask FALSE variables specified replaced. partial TRUE specified variables replaced parameter ask ignored. expand Used internally. use . list TRUE result always list, even one graph returned list.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/replaceVariables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replaces variables in a general graph with specified numeric values — replaceVariables","text":"graph matrix variables replaced specified numeric values. list theses graphs matrices variable one value.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/replaceVariables.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Replaces variables in a general graph with specified numeric values — replaceVariables","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/replaceVariables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replaces variables in a general graph with specified numeric values — replaceVariables","text":"","code":"graph <- HungEtWang2010() replaceVariables(graph, list(\"tau\"=0.5,\"omega\"=0.5, \"nu\"=0.5)) #> A graphMCP graph #> H_{1,NI} (weight=1) #> H_{1,S} (weight=0) #> H_{2,NI} (weight=0) #> H_{2,S} (weight=0) #> Edges: #> H_{1,NI}  -( 0.5 )->  H_{1,S}  #> H_{1,NI}  -( 0.5 )->  H_{2,NI}  #> H_{1,S}  -( 0.5 )->  H_{2,NI}  #> H_{1,S}  -( 0.5 )->  H_{2,S}  #> H_{2,NI}  -( 0.5 )->  H_{1,S}  #> H_{2,NI}  -( 0.5 )->  H_{2,S}  #>  replaceVariables(graph, list(\"tau\"=c(0.1, 0.5, 0.9),\"omega\"=c(0.2, 0.8), \"nu\"=0.4)) #> [[1]] #> A graphMCP graph #> H_{1,NI} (weight=1) #> H_{1,S} (weight=0) #> H_{2,NI} (weight=0) #> H_{2,S} (weight=0) #> Edges: #> H_{1,NI}  -( 0.4 )->  H_{1,S}  #> H_{1,NI}  -( 0.6 )->  H_{2,NI}  #> H_{1,S}  -( 0.1 )->  H_{2,NI}  #> H_{1,S}  -( 0.9 )->  H_{2,S}  #> H_{2,NI}  -( 0.2 )->  H_{1,S}  #> H_{2,NI}  -( 0.8 )->  H_{2,S}  #>  #>  #> [[2]] #> A graphMCP graph #> H_{1,NI} (weight=1) #> H_{1,S} (weight=0) #> H_{2,NI} (weight=0) #> H_{2,S} (weight=0) #> Edges: #> H_{1,NI}  -( 0.4 )->  H_{1,S}  #> H_{1,NI}  -( 0.6 )->  H_{2,NI}  #> H_{1,S}  -( 0.5 )->  H_{2,NI}  #> H_{1,S}  -( 0.5 )->  H_{2,S}  #> H_{2,NI}  -( 0.2 )->  H_{1,S}  #> H_{2,NI}  -( 0.8 )->  H_{2,S}  #>  #>  #> [[3]] #> A graphMCP graph #> H_{1,NI} (weight=1) #> H_{1,S} (weight=0) #> H_{2,NI} (weight=0) #> H_{2,S} (weight=0) #> Edges: #> H_{1,NI}  -( 0.4 )->  H_{1,S}  #> H_{1,NI}  -( 0.6 )->  H_{2,NI}  #> H_{1,S}  -( 0.9 )->  H_{2,NI}  #> H_{1,S}  -( 0.1 )->  H_{2,S}  #> H_{2,NI}  -( 0.2 )->  H_{1,S}  #> H_{2,NI}  -( 0.8 )->  H_{2,S}  #>  #>  #> [[4]] #> A graphMCP graph #> H_{1,NI} (weight=1) #> H_{1,S} (weight=0) #> H_{2,NI} (weight=0) #> H_{2,S} (weight=0) #> Edges: #> H_{1,NI}  -( 0.4 )->  H_{1,S}  #> H_{1,NI}  -( 0.6 )->  H_{2,NI}  #> H_{1,S}  -( 0.1 )->  H_{2,NI}  #> H_{1,S}  -( 0.9 )->  H_{2,S}  #> H_{2,NI}  -( 0.8 )->  H_{1,S}  #> H_{2,NI}  -( 0.2 )->  H_{2,S}  #>  #>  #> [[5]] #> A graphMCP graph #> H_{1,NI} (weight=1) #> H_{1,S} (weight=0) #> H_{2,NI} (weight=0) #> H_{2,S} (weight=0) #> Edges: #> H_{1,NI}  -( 0.4 )->  H_{1,S}  #> H_{1,NI}  -( 0.6 )->  H_{2,NI}  #> H_{1,S}  -( 0.5 )->  H_{2,NI}  #> H_{1,S}  -( 0.5 )->  H_{2,S}  #> H_{2,NI}  -( 0.8 )->  H_{1,S}  #> H_{2,NI}  -( 0.2 )->  H_{2,S}  #>  #>  #> [[6]] #> A graphMCP graph #> H_{1,NI} (weight=1) #> H_{1,S} (weight=0) #> H_{2,NI} (weight=0) #> H_{2,S} (weight=0) #> Edges: #> H_{1,NI}  -( 0.4 )->  H_{1,S}  #> H_{1,NI}  -( 0.6 )->  H_{2,NI}  #> H_{1,S}  -( 0.9 )->  H_{2,NI}  #> H_{1,S}  -( 0.1 )->  H_{2,S}  #> H_{2,NI}  -( 0.8 )->  H_{1,S}  #> H_{2,NI}  -( 0.2 )->  H_{2,S}  #>  #>"},{"path":"https://merck.github.io/gMCPLite/reference/simConfint.html","id":null,"dir":"Reference","previous_headings":"","what":"Simultaneous confidence intervals for sequentially rejective multiple test\nprocedures — simConfint","title":"Simultaneous confidence intervals for sequentially rejective multiple test\nprocedures — simConfint","text":"Calculates simultaneous confidence intervals sequentially rejective multiple test procedures.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simConfint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simultaneous confidence intervals for sequentially rejective multiple test\nprocedures — simConfint","text":"","code":"simConfint(   object,   pvalues,   confint,   alternative = c(\"less\", \"greater\"),   estimates,   df,   alpha = 0.05,   mu = 0 )"},{"path":"https://merck.github.io/gMCPLite/reference/simConfint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simultaneous confidence intervals for sequentially rejective multiple test\nprocedures — simConfint","text":"object graph class graphMCP. pvalues numeric vector specifying p-values sequentially rejective MTP. confint One following: character string \"normal\", \"t\" function calculates confidence intervals.  confint==\"t\" parameter df must specified.  confint function must signature (\"character\", \"numeric\"), first parameter hypothesis name second marginal confidence level (see examples). alternative character string specifying alternative hypothesis, must \"greater\" \"less\". estimates Point estimates parameters interest. df Degree freedom numeric. alpha overall alpha level numeric scalar. mu numerical parameter vector null hypothesis.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simConfint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simultaneous confidence intervals for sequentially rejective multiple test\nprocedures — simConfint","text":"matrix columns giving lower confidence limits, point estimates upper confidence limits parameter. labeled \"lower bound\", \"estimate\" \"upper bound\". (1-level)/2 % (default 2.5% 97.5%).","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simConfint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simultaneous confidence intervals for sequentially rejective multiple test\nprocedures — simConfint","text":"details see given references.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simConfint.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simultaneous confidence intervals for sequentially rejective multiple test\nprocedures — simConfint","text":"Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: graphical approach sequentially rejective multiple test procedures. Statistics Medicine 2009 vol. 28 issue 4 page 586-604. http://www.meduniwien.ac./fwf_adaptive/papers/bretz_2009_22.pdf","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/simConfint.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simultaneous confidence intervals for sequentially rejective multiple test\nprocedures — simConfint","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simConfint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simultaneous confidence intervals for sequentially rejective multiple test\nprocedures — simConfint","text":"","code":"est <- c(\"H1\"=0.860382, \"H2\"=0.9161474, \"H3\"=0.9732953) # Sample standard deviations: ssd <- c(\"H1\"=0.8759528, \"H2\"=1.291310, \"H3\"=0.8570892)  pval <- c(0.01260, 0.05154, 0.02124)/2  simConfint(BonferroniHolm(3), pvalues=pval,     confint=function(node, alpha) {       c(est[node]-qt(1-alpha,df=9)*ssd[node]/sqrt(10), Inf)     }, estimates=est, alpha=0.025, mu=0, alternative=\"greater\") #>     lower bound  estimate upper bound #> H1  0.000000000 0.8603820         Inf #> H2 -0.007600126 0.9161474         Inf #> H3  0.000000000 0.9732953         Inf  # Note that the sample standard deviations in the following call # will be calculated from the pvalues and estimates. ci <- simConfint(BonferroniHolm(3), pvalues=pval,     confint=\"t\", df=9, estimates=est, alpha=0.025, alternative=\"greater\") ci #>       lower bound  estimate upper bound #> [1,]  0.000000000 0.8603820         Inf #> [2,] -0.007580967 0.9161474         Inf #> [3,]  0.000000000 0.9732953         Inf  # plotSimCI(ci)"},{"path":"https://merck.github.io/gMCPLite/reference/simes.on.subsets.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Simes on subsets, otherwise Bonferroni — simes.on.subsets.test","title":"Simes on subsets, otherwise Bonferroni — simes.on.subsets.test","text":"Weighted Simes test introduced Benjamini Hochberg (1997)","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simes.on.subsets.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simes on subsets, otherwise Bonferroni — simes.on.subsets.test","text":"","code":"simes.on.subsets.test(   pvalues,   weights,   alpha = 0.05,   adjPValues = TRUE,   verbose = FALSE,   subsets,   subset,   ... )"},{"path":"https://merck.github.io/gMCPLite/reference/simes.on.subsets.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simes on subsets, otherwise Bonferroni — simes.on.subsets.test","text":"pvalues numeric vector specifying p-values. weights numeric vector weights. alpha numeric specifying maximal allowed type one error rate. adjPValues==TRUE (default) parameter alpha used. adjPValues Logical scalar. TRUE (default) adjusted p-value weighted test returned. Otherwise adjPValues==FALSE logical value returned whether null hypothesis can rejected. verbose Logical scalar. TRUE verbose output generated. subsets list subsets given numeric vectors containing indices elementary hypotheses weighted Simes test applicable. subset numeric vector containing numbers indices currently tested elementary hypotheses. ... arguments possibly passed gMCP used test procedures one.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simes.on.subsets.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simes on subsets, otherwise Bonferroni — simes.on.subsets.test","text":"adjusted p-value decision rejection","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simes.on.subsets.test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simes on subsets, otherwise Bonferroni — simes.on.subsets.test","text":"additional argument list subsets must provided, states cases Simes test applicable (.e. hypotheses test belong one subsets), e.g. subsets <- list(c(\"H1\", \"H2\", \"H3\"), c(\"H4\", \"H5\", \"H6\")) Trimmed Simes test intersections two hypotheses otherwise weighted Bonferroni-test","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simes.on.subsets.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simes on subsets, otherwise Bonferroni — simes.on.subsets.test","text":"","code":"simes.on.subsets.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0)) #> [1] 0.2 simes.on.subsets.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE) #> [1] FALSE  graph <- BonferroniHolm(4) pvalues <- c(0.01, 0.05, 0.03, 0.02)  gMCP.extended(graph=graph, pvalues=pvalues, test=simes.on.subsets.test, subsets=list(1:2, 3:4)) #> gMCP-Result #>  #> Initial graph: #> A graphMCP graph #> H1 (weight=0.25) #> H2 (weight=0.25) #> H3 (weight=0.25) #> H4 (weight=0.25) #> Edges: #> H1  -( 0.333333333333333 )->  H2  #> H1  -( 0.333333333333333 )->  H3  #> H1  -( 0.333333333333333 )->  H4  #> H2  -( 0.333333333333333 )->  H1  #> H2  -( 0.333333333333333 )->  H3  #> H2  -( 0.333333333333333 )->  H4  #> H3  -( 0.333333333333333 )->  H1  #> H3  -( 0.333333333333333 )->  H2  #> H3  -( 0.333333333333333 )->  H4  #> H4  -( 0.333333333333333 )->  H1  #> H4  -( 0.333333333333333 )->  H2  #> H4  -( 0.333333333333333 )->  H3  #>  #>  #> P-values: #> [1] 0.01 0.05 0.03 0.02 #>  #> Adjusted p-values: #> [1] 0.04 0.06 0.06 0.06 #>  #> Alpha: 0.05  #>  #> Hypothesis rejected: #>    H1    H2    H3    H4  #>  TRUE FALSE FALSE FALSE  #>  #> Final graph after1steps: #> A graphMCP graph #> H1 (rejected, weight=0) #> H2 (weight=0.3333) #> H3 (weight=0.3333) #> H4 (weight=0.3333) #> Edges: #> H2  -( 0.5 )->  H3  #> H2  -( 0.5 )->  H4  #> H3  -( 0.5 )->  H2  #> H3  -( 0.5 )->  H4  #> H4  -( 0.5 )->  H2  #> H4  -( 0.5 )->  H3  #>"},{"path":"https://merck.github.io/gMCPLite/reference/simes.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Weighted Simes test — simes.test","title":"Weighted Simes test — simes.test","text":"Weighted Simes test introduced Benjamini Hochberg (1997)","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simes.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weighted Simes test — simes.test","text":"","code":"simes.test(   pvalues,   weights,   alpha = 0.05,   adjPValues = TRUE,   verbose = FALSE,   ... )"},{"path":"https://merck.github.io/gMCPLite/reference/simes.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weighted Simes test — simes.test","text":"pvalues numeric vector specifying p-values. weights numeric vector weights. alpha numeric specifying maximal allowed type one error rate. adjPValues==TRUE (default) parameter alpha used. adjPValues Logical scalar. TRUE (default) adjusted p-value weighted Simes test returned. Otherwise adjPValues==FALSE logical value returned whether null hypothesis can rejected. verbose Logical scalar. TRUE verbose output generated. ... arguments possibly passed gMCP used test procedures one.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simes.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weighted Simes test — simes.test","text":"adjusted p-value decision rejection","code":""},{"path":"https://merck.github.io/gMCPLite/reference/simes.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weighted Simes test — simes.test","text":"","code":"simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0)) #> [1] 0.2 simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE) #> [1] FALSE"},{"path":"https://merck.github.io/gMCPLite/reference/subgraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a subgraph — subgraph","title":"Get a subgraph — subgraph","text":"Given set nodes graph function creates subgraph containing specified nodes.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/subgraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a subgraph — subgraph","text":"","code":"subgraph(graph, subset)"},{"path":"https://merck.github.io/gMCPLite/reference/subgraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a subgraph — subgraph","text":"graph graph class graphMCP. subset logical character vector specifying nodes subgraph.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/subgraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a subgraph — subgraph","text":"subgraph containing specified nodes.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/subgraph.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get a subgraph — subgraph","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/subgraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a subgraph — subgraph","text":"","code":"graph <- improvedParallelGatekeeping() subgraph(graph, c(TRUE, FALSE, TRUE, FALSE)) #> A graphMCP graph #> Sum of weight: 0.5 #> H1 (weight=0.5) #> H3 (weight=0) #> Edges: #> H1  -( 0.5 )->  H3  #> H3  -( \\epsilon )->  H1  #>  subgraph(graph, c(\"H1\", \"H3\")) #> A graphMCP graph #> Sum of weight: 0.5 #> H1 (weight=0.5) #> H3 (weight=0) #> Edges: #> H1  -( 0.5 )->  H3  #> H3  -( \\epsilon )->  H1  #>"},{"path":"https://merck.github.io/gMCPLite/reference/substituteEps.html","id":null,"dir":"Reference","previous_headings":"","what":"Substitute Epsilon — substituteEps","title":"Substitute Epsilon — substituteEps","text":"Substitute Epsilon given value.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/substituteEps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Substitute Epsilon — substituteEps","text":"","code":"substituteEps(graph, eps = 10^(-3))"},{"path":"https://merck.github.io/gMCPLite/reference/substituteEps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Substitute Epsilon — substituteEps","text":"graph graph class graphMCP class entangledMCP. eps numeric scalar specifying value epsilon edges.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/substituteEps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Substitute Epsilon — substituteEps","text":"graph epsilons replaced given value.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/substituteEps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Substitute Epsilon — substituteEps","text":"details see given references.","code":""},{"path":[]},{"path":"https://merck.github.io/gMCPLite/reference/substituteEps.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Substitute Epsilon — substituteEps","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/substituteEps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Substitute Epsilon — substituteEps","text":"","code":"graph <- improvedParallelGatekeeping() graph #> A graphMCP graph #> H1 (weight=0.5) #> H2 (weight=0.5) #> H3 (weight=0) #> H4 (weight=0) #> Edges: #> H1  -( 0.5 )->  H3  #> H1  -( 0.5 )->  H4  #> H2  -( 0.5 )->  H3  #> H2  -( 0.5 )->  H4  #> H3  -( \\epsilon )->  H1  #> H3  -( 1-\\epsilon )->  H4  #> H4  -( \\epsilon )->  H2  #> H4  -( 1-\\epsilon )->  H3  #>  substituteEps(graph, eps=0.01) #> A graphMCP graph #> H1 (weight=0.5) #> H2 (weight=0.5) #> H3 (weight=0) #> H4 (weight=0) #> Edges: #> H1  -( 0.5 )->  H3  #> H1  -( 0.5 )->  H4  #> H2  -( 0.5 )->  H3  #> H2  -( 0.5 )->  H4  #> H3  -( 0.01 )->  H1  #> H3  -( 0.99 )->  H4  #> H4  -( 0.01 )->  H2  #> H4  -( 0.99 )->  H3  #>"},{"path":"https://merck.github.io/gMCPLite/reference/weighted.test.functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Weighted Test Functions for use with gMCP — weighted.test.functions","title":"Weighted Test Functions for use with gMCP — weighted.test.functions","text":"package gMCP provides following weighted test functions: bonferroni.test Bonferroni test - see ?bonferroni.test details. parametric.test Parametric test - see ?parametric.test details. simes.test Simes test - see ?simes.test details. bonferroni.trimmed.simes.test Trimmed Simes test intersections two hypotheses otherwise Bonferroni - see ?bonferroni.trimmed.simes.test details. simes..subsets.test Simes test intersections hypotheses certain sets otherwise Bonferroni - see ?simes..subsets.test details.","code":""},{"path":"https://merck.github.io/gMCPLite/reference/weighted.test.functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Weighted Test Functions for use with gMCP — weighted.test.functions","text":"Depending whether adjPValues==TRUE test functions return different values: adjPValues==TRUE minimal value alpha returned null hypothesis can rejected. possible (example case trimmed Simes test adjusted p-values can calculated), test function may throw error. adjPValues==FALSE logical value returned whether null hypothesis can rejected. provide test function write function takes least following arguments: pvalues numeric vector specifying p-values. weights numeric vector weights. alpha numeric specifying maximal allowed type one error rate. adjPValues==TRUE (default) parameter alpha used. adjPValues Logical scalar. TRUE adjusted p-value weighted test returned (possible - function call stop). Otherwise adjPValues==FALSE logical value returned whether null hypothesis can rejected. ... arguments possibly passed gMCP used test procedures one. following parameters predefined meaning: verbose Logical scalar. TRUE verbose output generated printed standard output subset  correlation","code":""},{"path":"https://merck.github.io/gMCPLite/reference/weighted.test.functions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Weighted Test Functions for use with gMCP — weighted.test.functions","text":"Kornelius Rohmeyer rohmeyer@small-projects.de","code":""},{"path":"https://merck.github.io/gMCPLite/reference/weighted.test.functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weighted Test Functions for use with gMCP — weighted.test.functions","text":"","code":"# The test function 'bonferroni.test' is used in by gMCP in the following call: graph <- BonferroniHolm(4) pvalues <- c(0.01, 0.05, 0.03, 0.02) alpha <- 0.05 r <- gMCP.extended(graph=graph, pvalues=pvalues, test=bonferroni.test, verbose=TRUE) #> Info: #> Subset {4}: rejected (adj-p: 0.02) #> Subset {3}: rejected (adj-p: 0.03) #> Subset {3,4}: rejected (adj-p: 0.04) #> Subset {2}: rejected (adj-p: 0.05) #> Subset {2,4}: rejected (adj-p: 0.04) #> Subset {2,3}: not rejected (adj-p: 0.06) #> Subset {2,3,4}: not rejected (adj-p: 0.06) #> Subset {1}: rejected (adj-p: 0.01) #> Subset {1,4}: rejected (adj-p: 0.02) #> Subset {1,3}: rejected (adj-p: 0.02) #> Subset {1,3,4}: rejected (adj-p: 0.03) #> Subset {1,2}: rejected (adj-p: 0.02) #> Subset {1,2,4}: rejected (adj-p: 0.03) #> Subset {1,2,3}: rejected (adj-p: 0.03) #> Subset {1,2,3,4}: rejected (adj-p: 0.04)   # For the intersection of all four elementary hypotheses this results in a call bonferroni.test(pvalues=pvalues, weights=getWeights(graph)) #> [1] 0.04 bonferroni.test(pvalues=pvalues, weights=getWeights(graph), adjPValues=FALSE) #> [1] TRUE  # bonferroni.test function: bonferroni.test <- function(pvalues, weights, alpha=0.05, adjPValues=TRUE, verbose=FALSE, ...) {   if (adjPValues) {     return(min(pvalues/weights))   } else {     return(any(pvalues<=alpha*weights))   } }"},{"path":[]},{"path":"https://merck.github.io/gMCPLite/news/index.html","id":"improvements-0-1-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"gMCPLite 0.1.1","text":"Added method references DOI description field DESCRIPTION file. Removed redundant \\dontrun{} examples. Replaced cat() message() suppression options like verbose available, except printing raw R Markdown content vignettes, requires cat(). Removed setting options(warn=-1) options(warn=0) function. Reset user’s options() vignettes changing .","code":""},{"path":"https://merck.github.io/gMCPLite/news/index.html","id":"gmcplite-010","dir":"Changelog","previous_headings":"","what":"gMCPLite 0.1.0","title":"gMCPLite 0.1.0","text":"Created fork gMCP 0.8-15 removed Java dependencies. Ported hGraph() function gsDesign 3.3.0, removed dependencies dplyr, tidyr magrittr, updated default wchar Unicode alpha.","code":""}]
